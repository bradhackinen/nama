<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nama.embedding_similarity API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nama.embedding_similarity</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import pandas as pd
import numpy as np
from tqdm import tqdm
from copy import copy, deepcopy
from collections import Counter
import torch
from torch import nn
from torch.utils.data import DataLoader
from transformers import AutoTokenizer, RobertaModel, get_cosine_schedule_with_warmup, get_linear_schedule_with_warmup, logging
from zipfile import ZipFile
import pickle
from io import BytesIO

from .scoring import score_predicted
from .matcher import Matcher


logging.set_verbosity_error()


def load_similarity_model(model_file, map_location=&#39;cpu&#39;, **kwargs):
    &#34;&#34;&#34;
    Load a similarity model from a saved model file.

    Parameters
    ----------
    model_file : str
        the file to load the model from
    map_location : str, optional
        This is a string that specifies the device to load the model on, defaults to &#34;cpu&#34;.

    -------
    model: EmbeddingSimilarityModel
    A similarity model
    &#34;&#34;&#34;
    return torch.load(model_file, map_location=map_location, **kwargs)


class TransformerProjector(nn.Module):
    &#34;&#34;&#34;
    A basic wrapper around a Hugging Face transformer model.
    Takes a string as input and produces an embedding vector of size d.
    &#34;&#34;&#34;

    def __init__(self,
                 model_class=RobertaModel,
                 model_name=&#39;roberta-base&#39;,
                 pooling=&#39;pooler&#39;,
                 normalize=True,
                 d=128,
                 prompt=&#39;&#39;,
                 device=&#39;cpu&#39;,
                 add_upper=True,
                 upper_case=False,
                 **kwargs):
        &#34;&#34;&#34;
        Initializes the TransformerProjector class.

        Parameters
        ----------
        model_class: The transformer model class
        model_name: str, optional (default=&#39;roberta-base&#39;)
            The name of the pretrained model to use.
        pooling: str, optional (default=&#39;pooler&#39;)
            The pooling method to use. Options are:
        normalize: bool, optional (default=True)
            Whether to normalize the embeddings to unit length.
        d: int, optional (default=128)
            The dimension of the embedding space. If you want to use the original embedding space, set this to None.
        prompt: str
            The prompt to use for the essay.
        device: str, optional (default=&#39;cpu&#39;)
            The device to run the model on.
        add_upper: bool, optional (default=True)
            If True, adds the upper-cased version of the prompt to the prompt.
        upper_case: bool, optional (default=False)
            If True, the input will be converted to upper case.
        &#34;&#34;&#34;
        super().__init__()

        self.model_class = model_class
        self.model_name = model_name
        self.pooling = pooling
        self.normalize = normalize
        self.d = d
        self.prompt = prompt
        self.add_upper = add_upper
        self.upper_case = upper_case

        self.tokenizer = AutoTokenizer.from_pretrained(model_name)

        try:
            self.transformer = model_class.from_pretrained(model_name)
        except OSError:
            self.transformer = model_class.from_pretrained(
                model_name, from_tf=True)

        self.dropout = torch.nn.Dropout(0.5)

        if d:
            # Project embedding to a lower dimension
            # Initialization based on random projection LSH (preserves
            # approximate cosine distances)
            self.projection = torch.nn.Linear(
                self.transformer.config.hidden_size, d)
            torch.nn.init.normal_(self.projection.weight)
            torch.nn.init.constant_(self.projection.bias, 0)

        self.to(device)

    def to(self, device):
        &#34;&#34;&#34;
        Moves the model to the specified device

        Parameters
        ----------
        device: str
            The device to which the model is to be moved
        &#34;&#34;&#34;
        super().to(device)
        self.device = device

    def encode(self, strings):
        &#34;&#34;&#34;
        Encodes the strings using the tokenizer

        Parameters
        ----------
        strings: list of str
            A list of strings to encode

        Returns
        -------
        input_ids: torch.tensor
            Input ids tensor
        attention_mask: torch.tensor
            Attention mask tensor
        &#34;&#34;&#34;
        if self.prompt is not None:
            strings = [self.prompt + s for s in strings]
        if self.add_upper:
            strings = [s + &#39; &lt;/s&gt; &#39; + s.upper() for s in strings]
        if self.upper_case:
            strings = [s + &#39; &lt;/s&gt; &#39; + s.upper() for s in strings]

        try:
            encoded = self.tokenizer(strings, padding=True, truncation=True)
        except Exception as e:
            print(strings)
            raise Exception(e)
        input_ids = torch.tensor(encoded[&#39;input_ids&#39;]).long()
        attention_mask = torch.tensor(encoded[&#39;attention_mask&#39;])

        return input_ids, attention_mask

    def forward(self, strings):
        &#34;&#34;&#34;
        Encodes the string into batches, and then passes them through the transformer model

        Parameters
        ----------
        strings: list of str
            A list of strings to embed

        Returns
        -------
        v: torch.tensor
            The last hidden state of the transformer
        &#34;&#34;&#34;
        with torch.no_grad():
            input_ids, attention_mask = self.encode(strings)

            input_ids = input_ids.to(device=self.device)
            attention_mask = attention_mask.to(device=self.device)

        # with amp.autocast(self.amp):
        batch_out = self.transformer(input_ids=input_ids,
                                     attention_mask=attention_mask,
                                     return_dict=True)

        if self.pooling == &#39;pooler&#39;:
            v = batch_out[&#39;pooler_output&#39;]
        elif self.pooling == &#39;mean&#39;:
            h = batch_out[&#39;last_hidden_state&#39;]

            # Compute mean of unmasked token vectors
            h = h * attention_mask[:, :, None]
            v = h.sum(dim=1) / attention_mask.sum(dim=1)[:, None]

        if self.d:
            v = self.projection(v)

        if self.normalize:
            v = v / torch.sqrt((v**2).sum(dim=1)[:, None])

        return v

    def config_optimizer(self, transformer_lr=1e-5, projection_lr=1e-4):
        &#34;&#34;&#34;
        Sets the configuration of the TransformerProjector optimizer

        Parameters
        ----------
        transformer_lr: float
            Learning rate for the transformer
        projection_lr: float
            Learning rate for the projection layer

        Returns
        -------
        optimizer: torch.optim.AdamW
            The configured optimizer
        &#34;&#34;&#34;

        parameters = list(self.named_parameters())
        grouped_parameters = [{&#39;params&#39;: [param for name,
                                          param in parameters if name.startswith(&#39;transformer&#39;) and name.endswith(&#39;bias&#39;)],
                               &#39;weight_decay_rate&#39;: 0.0,
                               &#39;lr&#39;: transformer_lr,
                               },
                              {&#39;params&#39;: [param for name,
                                          param in parameters if name.startswith(&#39;transformer&#39;) and not name.endswith(&#39;bias&#39;)],
                               &#39;weight_decay_rate&#39;: 0.0,
                               &#39;lr&#39;: transformer_lr,
                               },
                              {&#39;params&#39;: [param for name,
                                          param in parameters if name.startswith(&#39;projection&#39;)],
                               &#39;weight_decay_rate&#39;: 0.0,
                               &#39;lr&#39;: projection_lr,
                               },
                              ]

        # Drop groups with lr of 0
        grouped_parameters = [p for p in grouped_parameters if p[&#39;lr&#39;]]

        optimizer = torch.optim.AdamW(grouped_parameters)

        return optimizer


class ExpCosSimilarity(nn.Module):
    &#34;&#34;&#34;
    A trainable similarity scoring model that estimates the probability
    of a match as the negative exponent of 1+cosine distance between

    embeddings: p(match|v_i,v_j) = exp(-alpha*(1-v_i@v_j))
    &#34;&#34;&#34;

    def __init__(self, alpha=50, **kwargs):
        &#34;&#34;&#34;
        Initializes an a trainable alpha.

        Parameters
        ----------
        alpha: float, optional
            The alpha parameter in the paper, defaults to 50.
        &#34;&#34;&#34;

        super().__init__()

        self.alpha = nn.Parameter(torch.tensor(float(alpha)))

    def __repr__(self):
        &#34;&#34;&#34;
        Returns a string representation of the object.
        &#34;&#34;&#34;
        return f&#39;&lt;nama.ExpCosSimilarity with {self.alpha=}&gt;&#39;

    def forward(self, X):
        &#34;&#34;&#34;
        Scores a set of embedding similarities, returns a score between 0 and 1.

        Parameters
        ----------
        X: torch tensor
            the distance between the embeddings vectors

        Returns
        -------
        The score of the embeddings: torch tensor
        &#34;&#34;&#34;
        # Z is a scaled distance measure: Z=0 means that the score should be 1
        Z = self.alpha * (1 - X)
        return torch.clamp(torch.exp(-Z), min=0, max=1.0)

    def loss(self, X, Y, weights=None, decay=1e-6, epsilon=1e-6):
        &#34;&#34;&#34;
        Calculates the cross entropy loss with a simplified and numerically appropriate formula.
        $ $

        Parameters
        ----------
        X: torch tensor
            The set of embedding similarities
        Y: torch tensor
            The true labels
        weights: torch tensor, optional
            a tensor used to weights for the loss
        decay: float, optional
            This is the regularization parameter. It&#39;s a hyperparameter that can be tuned, defaults to 1e-6.
        epsilon: float, optional
            This is a small number that is added to the denominator to prevent division by zero, defaults to 1e-6.

        Returns
        -------
        The cross entropy loss of the embeddings: torch tensor
        &#34;&#34;&#34;

        Z = self.alpha * (1 - X)

        # Put epsilon floor to prevent overflow/undefined results
        with torch.no_grad():
            Z_eps_adjustment = torch.clamp(epsilon - Z, min=0)

        Z += Z_eps_adjustment

        loss = Y * Z - torch.xlogy(1 - Y, -torch.expm1(-Z))

        if weights is not None:
            loss *= weights * loss

        if decay:
            loss += decay * self.alpha**2

        return loss

    def score_to_cos(self, score):
        &#34;&#34;&#34;
        It takes a score and returns a cosine similarity.

        Parameters
        ----------
        score: float
            the score of the item

        Returns
        -------
        The cosine similarity between the two vectors: float
        &#34;&#34;&#34;
        if score &gt; 0:
            return 1 + np.log(score) / self.alpha.item()
        else:
            return -99

    def config_optimizer(self, lr=10):
        &#34;&#34;&#34;
        Sets the configuration of the ExpCosSimilarity optimizer

        Parameters
        ----------
        lr: float
            Learning rate for the loss function

        Returns
        -------
        optimizer: torch.optim.AdamW
            The configured optimizer
        &#34;&#34;&#34;
        optimizer = torch.optim.AdamW(self.parameters(), lr=lr, weight_decay=0)

        return optimizer


class ExponentWeights():
    &#34;&#34;&#34;The ExponentWeights class is used to calculate the weighted counts with a specified exponent.&#34;&#34;&#34;

    def __init__(self, weighting_exponent=0.5, **kwargs):
        &#34;&#34;&#34;
        Initialize the class with the specified weighting exponent.

        Parameters
        ----------
        weighting_exponent : float, optional
            The exponent to use for the weighting of the counts (default is 0.5).
        &#34;&#34;&#34;
        self.exponent = weighting_exponent

    def __call__(self, counts):
        &#34;&#34;&#34;
        Calculate the weighted counts using the specified exponent.

        Parameters
        ----------
        counts : np.ndarray
            The counts to be weighted.

        Returns
        -------
        np.ndarray
            The weighted counts.
        &#34;&#34;&#34;
        return counts**self.exponent


class EmbeddingSimilarityModel(nn.Module):
    &#34;&#34;&#34;
    A combined projector/scorer model that produces Embeddings objects
    as its primary output.
    &#34;&#34;&#34;
    # TODO add save for model hyper params

    def __init__(self,
                 projector_class=TransformerProjector,
                 score_class=ExpCosSimilarity,
                 weighting_class=ExponentWeights,
                 **kwargs):
        &#34;&#34;&#34;
        Initialize the EmbeddingSimilarityModel with the projector, score, and weighting models.

        Parameters
        ----------
        projector_class : The class of the projector model
        score_class : the similarity function used to compare the projected query and projected document
        weighting_class : This is the function that will be used to weight the scores of the different documents
        &#34;&#34;&#34;
        super().__init__()

        self.projector_model = projector_class(**kwargs)
        self.score_model = score_class(**kwargs)
        self.weighting_function = weighting_class(**kwargs)

        self.to(kwargs.get(&#39;device&#39;, &#39;cpu&#39;))

    def to(self, device):
        &#34;&#34;&#34;
        Moves the model to a specified device

        Parameters
        ----------
        device : the device to run the model on
        &#34;&#34;&#34;
        super().to(device)
        self.projector_model.to(device)
        self.score_model.to(device)
        self.device = device

    def save(self, savefile):
        &#34;&#34;&#34;
        Saves the model to a file.

        Parameters
        ----------
        savefile : the file to save the model to
        &#34;&#34;&#34;
        torch.save(self, savefile)

    def load_embeddings(self, f):
        &#34;&#34;&#34;
        Load embeddings from custom embedding archive format.

        Parameters
        ----------
        f : the file path to the embeddings
        &#34;&#34;&#34;
        raise NotImplementedError

        with ZipFile(f, &#39;r&#39;) as zip:
            score_model = pickle.loads(zip.read(&#39;score_model.pkl&#39;))
            weighting_function = pickle.loads(
                zip.read(&#39;weighting_function.pkl&#39;))
            strings_df = pd.read_csv(zip.open(&#39;strings.csv&#39;), na_filter=False)
            V = np.load(zip.open(&#39;V.npy&#39;))

            return Embeddings(
                strings=strings_df[&#39;string&#39;].values,
                counts=torch.tensor(strings_df[&#39;count&#39;].values),
                score_model=score_model,
                weighting_function=weighting_function,
                V=torch.tensor(V)
            )

    @torch.no_grad()
    def embed(
            self,
            input,
            to=None,
            batch_size=64,
            progress_bar=True,
            **kwargs):
        &#34;&#34;&#34;
        Construct an Embeddings object from input strings or a Matcher.

        Parameters
        ----------
        input : a list of strings or a Matcher object
        to : the device to put the embeddings on. If you&#39;re using a GPU, you&#39;ll want to put them on the GPU (optional)
        batch_size : The number of strings to embed at once, defaults to 64 (optional)
        progress_bar : Whether to show a progress bar, defaults to True (optional)

        Returns
        -------
        An Embeddings object.
        &#34;&#34;&#34;

        if to is None:
            to = self.device

        if isinstance(input, Matcher):
            strings = input.strings()
            counts = torch.tensor(
                [input.counts[s] for s in strings], device=self.device).float().to(to)

        else:
            strings = list(input)
            counts = torch.ones(
                len(strings),
                device=self.device).float().to(to)

        input_loader = DataLoader(
            strings, batch_size=batch_size, num_workers=0)

        self.projector_model.eval()

        V = None
        batch_start = 0
        with tqdm(total=len(strings), delay=1, desc=&#39;Embedding strings&#39;, disable=not progress_bar) as pbar:
            for batch_strings in input_loader:

                v = self.projector_model(batch_strings).detach().to(to)

                if V is None:
                    # Use v to determine dim and dtype of pre-allocated embedding tensor
                    # (Pre-allocating avoids duplicating tensors with a big .cat() operation)
                    V = torch.empty(
                        len(strings), v.shape[1], device=to, dtype=v.dtype)

                V[batch_start:batch_start + len(batch_strings), :] = v

                pbar.update(len(batch_strings))
                batch_start += len(batch_strings)

        score_model = copy(self.score_model)
        score_model.load_state_dict(self.score_model.state_dict())
        score_model.to(to)

        weighting_function = deepcopy(self.weighting_function)

        return Embeddings(strings=strings,
                          V=V.detach(),
                          counts=counts.detach(),
                          score_model=score_model,
                          weighting_function=weighting_function,
                          device=to)

    def train(
            self,
            training_matcher,
            max_epochs=1,
            batch_size=8,
            score_decay=0,
            regularization=0,
            transformer_lr=1e-5,
            projection_lr=1e-5,
            score_lr=10,
            warmup_frac=0.1,
            max_grad_norm=1,
            dropout=False,
            validation_matcher=None,
            target=&#39;F1&#39;,
            restore_best=True,
            val_seed=None,
            validation_interval=1000,
            early_stopping=True,
            early_stopping_patience=3,
            verbose=False,
            progress_bar=True,
            **kwargs):
        &#34;&#34;&#34;
        Trains the projector_model and score_model to predict match probabilities
        using the training_matcher as a source of &#34;correct&#34; matches.

        Training algorithm uses contrastive learning with hard-positive
        and hard-negative mining to fine tune the projector model to place
        matched strings near to each other in embedding space, while
        simultaneously calibrating the score_model to predict the match
        probabilities as a function of cosine distance

        Parameters
        ----------
        training_matcher : :class:`Matching`
            A Matching object with training data.
        max_epochs : int, optional (default=1)
            The number of epochs to train for.
        batch_size : int, optional (default=8)
            The number of strings to use in each training batch.
        score_decay : float, optional (default=0)
            A regularization parameter for the score model, similar to L2 regularization, but applied to the cosine distance between embeddings.
        regularization : float, optional (default=0)
        transformer_lr : float
            Learning rate for the transformer.
        projection_lr : float
            Learning rate for the projection layer.
        score_lr : float, optional (default=10)
            Learning rate for the score model.
        warmup_frac : float
            The fraction of training steps to use for the warm-up period.
        max_grad_norm : float, optional (default=1)
            The maximum gradient norm to clip to.
        dropout : bool, optional (default=False)
            Whether to use dropout in the transformer model.
        validation_matcher : :class:`Matching`, optional
            A matcher object used to evaluate the model during training.
        target : str, optional (default=&#39;F1&#39;)
            The metric to use for early stopping.
        restore_best : bool, optional (default=True)
            If True, the model will be restored to the state with the best validation score.
        val_seed : int, optional
            A random seed for validation, if desired.
        validation_interval : int, optional (default=1000)
            How often to run validation checks.
        early_stopping : bool, optional (default=True)
            If True, stop training if the validation score doesn&#39;t improve for `early_stopping_patience` epochs.
        early_stopping_patience : int, optional (default=3)
            How many validation checks to wait before stopping training.
        verbose : bool, optional (default=False)
            Print out the training progress, defaults to False (optional)
        progress_bar: bool
            Whether to show a progress bar during training, defaults to True (optional)

        Returns
        -------
        The return is a tuple of two dataframes. The first dataframe is the history of the
        training. The second dataframe is the validation scores.
        &#34;&#34;&#34;
        best_state = None
        if validation_matcher is None:
            early_stopping = False
            restore_best = False

        num_training_steps = max_epochs * len(training_matcher) // batch_size
        num_warmup_steps = int(warmup_frac * num_training_steps)

        if transformer_lr or projection_lr:
            embedding_optimizer = self.projector_model.config_optimizer(
                transformer_lr, projection_lr)
            embedding_scheduler = get_cosine_schedule_with_warmup(
                embedding_optimizer,
                num_warmup_steps=num_warmup_steps,
                num_training_steps=num_training_steps)
        if score_lr:
            score_optimizer = self.score_model.config_optimizer(score_lr)
            score_scheduler = get_linear_schedule_with_warmup(
                score_optimizer,
                num_warmup_steps=num_warmup_steps,
                num_training_steps=num_training_steps)

        step = 0
        self.history = []
        self.val_scores = []
        self.validation_scores = []
        for epoch in range(max_epochs):

            global_embeddings = self.embed(training_matcher)

            strings = global_embeddings.strings
            V = global_embeddings.V
            w = global_embeddings.w

            groups = torch.tensor(
                [global_embeddings.string_map[training_matcher[s]] for s in strings], device=self.device)

            # Normalize weights to make learning rates more general
            if w is not None:
                w = w / w.mean()

            shuffled_ids = list(range(len(strings)))
            random.shuffle(shuffled_ids)

            if dropout:
                self.projector_model.train()
            else:
                self.projector_model.eval()

            for batch_start in tqdm(
                    range(
                        0,
                        len(strings),
                        batch_size),
                    desc=f&#39;training epoch {epoch}&#39;,
                    disable=not progress_bar):

                h = {&#39;epoch&#39;: epoch, &#39;step&#39;: step}

                batch_i = shuffled_ids[batch_start:batch_start + batch_size]

                # Recycle ids from the beginning to pad the last batch if
                # necessary
                if len(batch_i) &lt; batch_size:
                    batch_i = batch_i + \
                        shuffled_ids[:(batch_size - len(batch_i))]

                &#34;&#34;&#34;
                Find highest loss match for each batch string (global search)

                Note: If we compute V_i with dropout enabled, it will add noise
                to the embeddings and prevent the same pairs from being selected
                every time.
                &#34;&#34;&#34;
                V_i = self.projector_model(strings[batch_i])

                # Update global embedding cache
                V[batch_i, :] = V_i.detach()

                with torch.no_grad():

                    global_X = V_i @ V.T
                    global_Y = (groups[batch_i][:, None]
                                == groups[None, :]).float()

                    if w is not None:
                        global_W = torch.outer(w[batch_i], w)
                    else:
                        global_W = None

                # Train scoring model only
                if score_lr:
                    # Make sure gradients are enabled for score model
                    self.score_model.requires_grad_(True)

                    global_loss = self.score_model.loss(
                        global_X, global_Y, weights=global_W, decay=score_decay)

                    score_optimizer.zero_grad()
                    global_loss.nanmean().backward()
                    torch.nn.utils.clip_grad_norm_(
                        self.score_model.parameters(), max_norm=max_grad_norm)

                    score_optimizer.step()
                    score_scheduler.step()

                    h[&#39;score_lr&#39;] = score_optimizer.param_groups[0][&#39;lr&#39;]
                    h[&#39;global_mean_cos&#39;] = global_X.mean().item()
                    try:
                        h[&#39;score_alpha&#39;] = self.score_model.alpha.item()
                    except BaseException:
                        pass

                else:
                    with torch.no_grad():
                        global_loss = self.score_model.loss(global_X, global_Y)

                h[&#39;global_loss&#39;] = global_loss.detach().nanmean().item()

                # Train projector model
                if (transformer_lr or projection_lr) and step &lt;= num_warmup_steps + \
                        num_training_steps:

                    # Turn off score model updating - only want to train
                    # projector here
                    self.score_model.requires_grad_(False)

                    # Select hard training examples
                    with torch.no_grad():
                        batch_j = global_loss.argmax(dim=1).flatten()

                        if w is not None:
                            batch_W = torch.outer(w[batch_i], w[batch_j])
                        else:
                            batch_W = None

                    # Train the model on the selected high-loss pairs
                    V_j = self.projector_model(strings[batch_j.tolist()])

                    # Update global embedding cache
                    V[batch_j, :] = V_j.detach()

                    batch_X = V_i @ V_j.T
                    batch_Y = (groups[batch_i][:, None] ==
                               groups[batch_j][None, :]).float()
                    h[&#39;batch_obs&#39;] = len(batch_i) * len(batch_j)

                    batch_loss = self.score_model.loss(
                        batch_X, batch_Y, weights=batch_W)

                    if regularization:
                        # Apply Global Orthogonal Regularization from
                        # https://arxiv.org/abs/1708.06320
                        gor_Y = (groups[batch_i][:, None] !=
                                 groups[batch_i][None, :]).float()
                        gor_n = gor_Y.sum()
                        if gor_n &gt; 1:
                            gor_X = (V_i @ V_i.T) * gor_Y
                            gor_m1 = 0.5 * gor_X.sum() / gor_n
                            gor_m2 = 0.5 * (gor_X**2).sum() / gor_n
                            batch_loss += regularization * \
                                (gor_m1 + torch.clamp(gor_m2 - 1 / self.projector_model.d, min=0))

                    h[&#39;batch_nan&#39;] = torch.isnan(
                        batch_loss.detach()).sum().item()

                    embedding_optimizer.zero_grad()
                    batch_loss.nanmean().backward()

                    torch.nn.utils.clip_grad_norm_(
                        self.parameters(), max_norm=max_grad_norm)

                    embedding_optimizer.step()
                    embedding_scheduler.step()

                    h[&#39;transformer_lr&#39;] = embedding_optimizer.param_groups[1][&#39;lr&#39;]
                    h[&#39;projection_lr&#39;] = embedding_optimizer.param_groups[-1][&#39;lr&#39;]

                    # Save stats
                    h[&#39;batch_loss&#39;] = batch_loss.detach().mean().item()
                    h[&#39;batch_pos_target&#39;] = batch_Y.detach().mean().item()

                self.history.append(h)
                step += 1

                if (validation_matcher is not None) and not (
                        step % validation_interval):
                    print(
                        f&#39;\nValidation results at step {step} (current epoch {epoch})&#39;)
                    validation = len(self.validation_scores)

                    with torch.no_grad():
                        val_scores = self.test(validation_matcher)

                        val_scores[&#39;step&#39;] = step - 1
                        val_scores[&#39;epoch&#39;] = epoch
                        val_scores[&#39;validation&#39;] = validation

                        if val_scores:
                            self.validation_scores.append(val_scores)

                    # Print validation stats
                    if verbose:
                        print(
                            f&#39;\nValidation results at step {step} (current epoch {epoch})&#39;)
                        for k, v in val_scores.items():
                            print(f&#39;    {k}: {v:.4f}&#39;)

                        print(list(self.score_model.named_parameters()))

                    # Update best saved model
                    if restore_best and best_state:
                        if val_scores[target] &gt;= max(
                                h[target] for h in self.validation_scores):
                            best_state = deepcopy({
                                &#39;state_dict&#39;: self.state_dict(),
                                &#39;val_scores&#39;: val_scores
                            })

                    if early_stopping and (
                            validation - best_state[&#39;val_scores&#39;][&#39;validation&#39;] &gt; early_stopping_patience):
                        print(
                            f&#39;Stopping training ({early_stopping_patience} validation checks since best validation score)&#39;)
                        break

        if restore_best:
            print(
                f&#34;Restoring to best state (step {best_state[&#39;val_scores&#39;][&#39;step&#39;]}):&#34;)
            for k, v in best_state[&#39;val_scores&#39;].items():
                print(f&#39;    {k}: {v:.4f}&#39;)

            self.to(&#39;cpu&#39;)
            self.load_state_dict(best_state[&#39;state_dict&#39;])
            self.to(self.device)

        return pd.DataFrame(self.history), pd.DataFrame(self.validation_scores)

    def predict(self, input, **kwargs):
        &#34;&#34;&#34;
        Predict the groupings for the given input.

        Parameters
        ----------
        input : Matcher
            the matcher to make the groupings predictions with
        **kwargs : dict
            Additional keyword arguments to pass the Embeddings.predict() function

        Returns
        -------
        Matcher
            An Matcher object containing the predicted groups
        &#34;&#34;&#34;
        embeddings = self.embed(input, **kwargs)
        return embeddings.predict(**kwargs)

    def test(self, gold_matcher, embed=None):
        &#34;&#34;&#34;
        Returns scores of predicted groupings vs the gold_matcher.

        Parameters
        ----------
        gold_matcher : Matcher
            The matcher compare the predictions with
        embed : Embeddings, optional
            The embeddings to use. If None, then the embeddings are generated from the gold_matcher

        Returns
        -------
        dict
            The scores of the predicted embeddings
        &#34;&#34;&#34;
        if not embed:
            embeddings = self.embed(gold_matcher, verbose=False)
        else:
            embeddings = embed

        predicted = embeddings.predict()

        scores = score_predicted(predicted, gold_matcher)

        return scores


class Embeddings(nn.Module):
    &#34;&#34;&#34;
    Stores embeddings for a fixed array of strings and provides methods for
    clustering the strings to create Matcher objects according to different
    algorithms.
    &#34;&#34;&#34;

    def __init__(
            self,
            strings,
            V,
            score_model,
            weighting_function,
            counts,
            device=&#39;cpu&#39;):
        &#34;&#34;&#34;
        Initialize the Embeddings object.

        Parameters
        ----------
        strings : list
            List of strings that we want to be able to score.
        V : int
            The size of the vocabulary.
        score_model : function
            A function that takes in a string and returns a score.
        weighting_function : function
            A function that takes a list of counts and returns a list of weights.
        counts : dict
            Dictionary of counts of each string in the vocabulary.
        device : str
            The device to run the model on. Default: &#39;cpu&#39;

        &#34;&#34;&#34;
        super().__init__()

        self.strings = np.array(list(strings))
        self.string_map = {s: i for i, s in enumerate(strings)}
        self.V = V
        self.counts = counts
        self.w = weighting_function(counts)
        self.score_model = score_model
        self.weighting_function = weighting_function
        self.device = device

        self.to(device)

    def __repr__(self):
        &#34;&#34;&#34;Return a string representation of the Embeddings object&#34;&#34;&#34;
        return f&#39;&lt;nama.Embeddings containing {self.V.shape[1]}-d vectors for {len(self)} strings&#39;

    def to(self, device):
        &#34;&#34;&#34;
        Moves the model to a specified device.

        Parameters
        ----------
        device : str
            The device to run the model on.
        &#34;&#34;&#34;
        super().to(device)
        self.V = self.V.to(device)
        self.counts = self.counts.to(device)
        self.w = self.w.to(device)
        self.score_model.to(device)
        self.device = device

    def save(self, f):
        &#34;&#34;&#34;
        Saves the embedding vectors, score model, weighting function, and strings and counts to an archive format.

        Parameters
        ----------
        f : str
            The file to save to.
        &#34;&#34;&#34;
        with ZipFile(f, &#39;w&#39;) as zip:

            # Write score model
            zip.writestr(&#39;score_model.pkl&#39;, pickle.dumps(self.score_model))

            # Write score model
            zip.writestr(
                &#39;weighting_function.pkl&#39;,
                pickle.dumps(
                    self.weighting_function))

            # Write string info
            strings_df = pd.DataFrame().assign(
                string=self.strings,
                count=self.counts.to(&#39;cpu&#39;).numpy())
            zip.writestr(&#39;strings.csv&#39;, strings_df.to_csv(index=False))

            # Write embedding vectors
            byte_io = BytesIO()
            np.save(byte_io, self.V.to(&#39;cpu&#39;).numpy(), allow_pickle=False)
            zip.writestr(&#39;V.npy&#39;, byte_io.getvalue())

    def __getitem__(self, arg):
        &#34;&#34;&#34;
        Slices the embeddings and its matcher, and returns a new embedding with the same properties as the original, but with the slice applied.

        Parameters
        ----------
        arg : slice or Matcher or iter
            Slice of the Embeddings. Can be type `slice`, `Matcher` or `iter`.

        Returns
        -------
        Embedding
            A new `Embedding` object with the same attributes as the original, but with the strings, `V`, counts, `w`, and `string_map` attributes sliced according to the input.
        &#34;&#34;&#34;
        if isinstance(arg, slice):
            i = arg
        elif isinstance(arg, Matcher):
            return self[arg.strings()]
        elif hasattr(arg, &#39;__iter__&#39;):
            # Return a subset of the embeddings and their weights
            string_map = self.string_map
            i = [string_map[s] for s in arg]

            if i == list(range(len(self))):
                # Just selecting the whole matcher - no need to slice the
                # embedding
                return copy(self)
        else:
            raise ValueError(
                f&#39;Unknown slice input type ({type(input)}). Can only slice Embedding with a slice, matcher, or iterable.&#39;)

        new = copy(self)
        new.strings = self.strings[i]
        new.V = self.V[i]
        new.counts = self.counts[i]
        new.w = self.w[i]
        new.string_map = {s: i for i, s in enumerate(new.strings)}

        return new

    def embed(self, matcher):
        &#34;&#34;&#34;
        Constructs an updated `Embeddings` object with counts from the input Matcher.

        Parameters
        ----------
        matcher : Matcher
            A `Matcher` object.

        Returns
        -------
        Embeddings
            A new `Embeddings` object with updated counts and weights.
        &#34;&#34;&#34;
        new = self[matcher]
        new.counts = torch.tensor([matcher.counts[s]
                                  for s in new.strings], device=self.device)
        new.w = new.weighting_function(new.counts)

        return new

    def __len__(self):
        &#34;&#34;&#34;
        Returns:
            int: Number of strings stored in the Embeddings object.
        &#34;&#34;&#34;
        return len(self.strings)

    def _matcher_to_group_ids(self, matcher):
        &#34;&#34;&#34;
        Convert a Matcher object to group IDs.

        Args:
            matcher: compiled regex object

        Returns:
            list of str: A list of strings
        &#34;&#34;&#34;
        group_id_map = {g: i for i, g in enumerate(matcher.groups.keys())}
        group_ids = torch.tensor([group_id_map[matcher[s]]
                                 for s in self.strings]).to(self.device)
        return group_ids

    def _group_ids_to_matcher(self, group_ids):
        &#34;&#34;&#34;
        Convert group IDs to a Matcher object.

        Args:
            group_ids: A tensor of group ids

        Returns:
            Matcher: A matcher object
        &#34;&#34;&#34;
        if isinstance(group_ids, torch.Tensor):
            group_ids = group_ids.to(&#39;cpu&#39;).numpy()

        strings = self.strings
        counts = self.counts.to(&#39;cpu&#39;).numpy()

        # Sort by group and string count
        g_sort = np.lexsort((counts, group_ids))
        group_ids = group_ids[g_sort]
        strings = strings[g_sort]
        counts = counts[g_sort]

        # Identify group boundaries and split locations
        split_locs = np.nonzero(group_ids[1:] != group_ids[:-1])[0] + 1

        # Get grouped strings as separate arrays
        groups = np.split(strings, split_locs)

        # Build the matcher
        matcher = Matcher()
        matcher.counts = Counter({s: int(c) for s, c in zip(strings, counts)})
        matcher.labels = {s: g[-1] for g in groups for s in g}
        matcher.groups = {g[-1]: list(g) for g in groups}

        return matcher

    @torch.no_grad()
    def _fast_predict(
            self,
            threshold=0.5,
            base_matcher=None,
            progress_bar=True,
            batch_size=64):
        &#34;&#34;&#34;
        For each embedding, find all embeddings that are similar to it and assign them to the same group.

        Parameters
        ----------
        threshold : float
            The threshold for the jaccard score.
        base_matcher : Matcher, optional
            A matcher object that has already been run on the embeddings. This is used to speed up the matching process.
        progress_bar : bool, optional
            Whether to show a progress bar, defaults to True.
        batch_size : int, optional
            The number of embeddings to process at once, defaults to 64.

        Returns
        -------
        Matcher
        A matcher object.
        &#34;&#34;&#34;
        if base_matcher is not None:
            # self = self.embed(base_matcher)
            group_ids = self._matcher_to_group_ids(base_matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        V = self.V
        cos_threshold = self.score_model.score_to_cos(threshold)

        for batch_start in tqdm(
                range(
                    0,
                    len(self),
                    batch_size),
                delay=1,
                desc=&#39;Predicting matches&#39;,
                disable=not progress_bar):

            i_slice = slice(batch_start, batch_start + batch_size)
            j_slice = slice(batch_start + 1, None)

            g_i = group_ids[i_slice]
            g_j = group_ids[j_slice]

            # Find j&#39;s with jaccard &gt; threshold (&#34;matches&#34;)
            batch_matched = (V[i_slice] @ V[j_slice].T &gt;= cos_threshold) \
                * (g_i[:, None] != g_j[None, :])

            for k, matched in enumerate(batch_matched):
                if matched.any():
                    # Get the group ids of the matched j&#39;s
                    matched_groups = g_j[matched]

                    # Identify all embeddings in these groups
                    ids_to_group = torch.isin(group_ids, matched_groups)

                    # Assign all matched embeddings to the same group
                    group_ids[ids_to_group] = g_i[k].clone()

        return self._group_ids_to_matcher(group_ids)

    @torch.no_grad()
    def predict(self,
                threshold=0.5,
                group_threshold=None,
                separate_strings=[],
                base_matcher=None,
                batch_size=64,
                progress_bar=True):
        &#34;&#34;&#34;
        Unite embedding strings according to predicted pairwise similarity.

        - &#34;base_matcher&#34; will be used to inialize the group_ids before uniting new matches
        - &#34;theshold&#34; sets the minimimum match similarity required to unite two strings.
            - Note that strings with similarity&lt;threshold can end up matched if they are
              linked by a chain of sufficiently similar strings (matching is transitive).
              &#34;group_threshold&#34; can be used to add an additional constraing on the minimum
              similarity within each group.
        - &#34;group_threshold&#34; sets the minimum similarity required within a single group.
          If &#34;group_threshold&#34; != None, string pairs with similarity&gt;threshold are identified
          and stored in order of similarity. Highest similarity strings are matched first,
          and before each time a pair of strings is united, the function checks if this will
          result in grouping any two strings with similarity&lt;group_threshold. If so, this pair
          is skipped. This version of the algorithm is slower than the one used when
          &#34;group_threshold=None.
        - &#34;separate_strings&#34; takes a list of strings that should never be united with each
          other (these strings will still be united with other strings)

        :param threshold: The minimum similarity required to unite two strings
        :param group_threshold: the minimum similarity required within a single group
        :param separate_strings: a list of strings that should never be united with each other (these
        strings will still be united with other strings)
        :param base_matcher: This is a matcher object that you can use to initialize the group_ids before
        uniting new matches
        :param batch_size: The number of embeddings to process at once, defaults to 64 (optional)
        :param progress_bar: Whether to show a progress bar, defaults to True (optional)
        :return: A Matcher object
        &#34;&#34;&#34;

        # Use the faster prediction algorithm if possible
        if not (group_threshold or separate_strings):

            return self._fast_predict(
                threshold=threshold,
                base_matcher=base_matcher,
                batch_size=batch_size,
                progress_bar=progress_bar)

        if base_matcher is not None:
            # self = self.embed(base_matcher)
            group_ids = self._matcher_to_group_ids(base_matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        V = self.V
        cos_threshold = self.score_model.score_to_cos(threshold)
        if group_threshold is not None:
            separate_cos = self.score_model.score_to_cos(group_threshold)

        # First collect all pairs to match (can be memory intensive!)
        matches = []
        cos_scores = []
        for batch_start in tqdm(range(0, len(self), batch_size),
                                desc=&#39;Scoring pairs&#39;,
                                delay=1, disable=not progress_bar):

            i_slice = slice(batch_start, batch_start + batch_size)
            j_slice = slice(batch_start + 1, None)

            # Find j&#39;s with jaccard &gt; threshold (&#34;matches&#34;)
            batch_cos = V[i_slice] @ V[j_slice].T

            # Search upper diagonal entries only
            # (note j_slice starting index is offset by one)
            batch_cos = torch.triu(batch_cos)

            bi, bj = torch.nonzero(batch_cos &gt;= cos_threshold, as_tuple=True)

            if len(bi):
                # Convert batch index locations to global index locations
                i = bi + batch_start
                j = bj + batch_start + 1

                cos = batch_cos[bi, bj]

                # Can skip strings that are already matched in the base matcher
                unmatched = group_ids[i] != group_ids[j]
                i = i[unmatched]
                j = j[unmatched]
                cos = cos[unmatched]

                if len(i):
                    batch_matches = torch.hstack([i[:, None], j[:, None]])

                    matches.append(batch_matches.to(&#39;cpu&#39;).numpy())
                    cos_scores.append(cos.to(&#39;cpu&#39;).numpy())

        # Then unite the pairs in priority order, checking for violations of the
        # separation arguments
        if matches:
            matches = np.vstack(matches)
            cos_scores = np.hstack(cos_scores).T

            # Sort matches in descending order of score
            m_sort = cos_scores.argsort()[::-1]
            matches = matches[m_sort]

            # Set up tensors
            matches = torch.tensor(matches).to(self.device)
            separate_strings = set(separate_strings)
            separated = torch.tensor(
                [s in separate_strings for s in self.strings]).to(self.device)

            n_matches = matches.shape[0]
            with tqdm(total=n_matches, desc=&#39;Uniting matches&#39;,
                      delay=1, disable=not progress_bar) as p_bar:

                while len(matches):

                    # Select the current match pair and remove it from the
                    # queue
                    match_pair = matches[0]
                    matches = matches[1:]

                    # Get the groups of the current match pair
                    g = group_ids[match_pair]

                    # Identify which strings should be united
                    to_unite = (group_ids == g[0]) | (group_ids == g[1])

                    # Flag whether uniting this pair will unite any separated
                    # strings
                    any_separated = separated[to_unite].sum() &gt; 1

                    # Flag whether the new group will have three or more
                    # strings
                    singletons = to_unite.sum() &lt; 3

                    if any_separated:
                        unite_ok = False
                    else:
                        if singletons:
                            unite_ok = True
                        else:
                            if group_threshold is None:
                                unite_ok = True
                            else:
                                V0 = V[group_ids == g[0], :]
                                V1 = V[group_ids == g[1], :]

                                unite_ok = (V0 @ V1.T).min() &gt;= separate_cos

                    if unite_ok:

                        # Unite groups
                        group_ids[to_unite] = g[0]

                        # If we are uniting more than two strings, we can eliminate
                        # some redundant matches in the queue
                        if not singletons:
                            # Removed queued matches that are now in the same
                            # group
                            matches = matches[group_ids[matches[:, 0]]
                                              != group_ids[matches[:, 1]]]
                    else:
                        # Remove queued matches connecting these groups
                        matches = matches[torch.isin(group_ids[matches[:, 0]], g, invert=True)
                                          | torch.isin(group_ids[matches[:, 1]], g, invert=True)]

                    # Update progress bar
                    p_bar.update(n_matches - matches.shape[0])
                    n_matches = matches.shape[0]

        return self._group_ids_to_matcher(group_ids)

    @torch.no_grad()
    def voronoi(
            self,
            seed_strings,
            threshold=0,
            base_matcher=None,
            progress_bar=True,
            batch_size=64):
        &#34;&#34;&#34;
        Unite embedding strings with each string&#39;s most similar seed string.

        - &#34;base_matcher&#34; will be used to inialize the group_ids before uniting new matches
        - &#34;theshold&#34; sets the minimimum match similarity required between a string and seed string
          for the string to be matched. (i.e., setting theshold=0 will result in every embedding
          string to be matched its nearest seed string, while setting threshold=0.9 will leave
          strings that have similarity&lt;0.9 with their nearest seed string unaffected)

        returns: Matcher object

        :param seed_strings: a list of strings to use as seed strings
        :param threshold: The minimum similarity score required for a match, defaults to 0 (optional)
        :param base_matcher: The matcher object to use as a starting point. If None, then the embedding
        strings will be used as the starting point
        :param progress_bar: Whether to show a progress bar, defaults to True (optional)
        :param batch_size: The number of embedding strings to process at a time, defaults to 64
        (optional)
        &#34;&#34;&#34;

        if base_matcher is not None:
            # self = self.embed(base_matcher)
            group_ids = self._matcher_to_group_ids(base_matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        V = self.V
        cos_threshold = self.score_model.score_to_cos(threshold)

        seed_ids = torch.tensor([self.string_map[s]
                                for s in seed_strings]).to(self.device)
        V_seed = V[seed_ids]
        g_seed = group_ids[seed_ids]
        is_seed = torch.zeros(V.shape[0], dtype=torch.bool).to(self.device)
        is_seed[g_seed] = True

        for batch_start in tqdm(
                range(
                    0,
                    len(self),
                    batch_size),
                delay=1,
                desc=&#39;Predicting matches&#39;,
                disable=not progress_bar):

            batch_slice = slice(batch_start, batch_start + batch_size)

            batch_cos = V[batch_slice] @ V_seed.T

            max_cos, max_seed = torch.max(batch_cos, dim=1)

            # Get batch index locations where score &gt; threshold
            batch_i = torch.nonzero(max_cos &gt; cos_threshold)

            if len(batch_i):
                # Drop seed strings from matches (otherwise numerical precision
                # issues can allow seed strings to match to other strings)
                batch_i = batch_i[~is_seed[batch_slice][batch_i]]

                if len(batch_i):
                    # Get indices of matched strings
                    i = batch_i + batch_start

                    # Assign matched strings to the seed string&#39;s group
                    group_ids[i] = g_seed[max_seed[batch_i]]

        return self._group_ids_to_matcher(group_ids)

    @torch.no_grad()
    def _batch_scored_pairs(self, group_ids, batch_start, batch_size,
                            is_match=None,
                            min_score=None, max_score=None,
                            min_loss=None, max_loss=None):
        &#34;&#34;&#34;
        A private method used to compute the scored pairs within a batch. Computes the scores and losses for all pairs of strings in the batch,
        and returns the pairs, their scores, and their losses

        :param group_ids: The group ids of the strings in the batch
        :param batch_start: the index of the first string in the batch
        :param batch_size: The number of pairs to score at a time
        :param is_match: True to return only matches, False to return only non-matches, None to return all
        pairs
        :param min_score: minimum score for a pair to be included in the results
        :param max_score: The maximum score for a pair to be included in the results
        :param min_loss: minimum loss for a pair to be included in the results
        :param max_loss: The maximum loss for a pair to be included in the results
        &#34;&#34;&#34;
        strings = self.strings
        V = self.V
        w = self.w

        # Create simple slice objects to avoid creating copies with advanced
        # indexing
        i_slice = slice(batch_start, batch_start + batch_size)
        j_slice = slice(batch_start + 1, None)

        X = V[i_slice] @ V[j_slice].T
        Y = (group_ids[i_slice, None] == group_ids[None, j_slice]).float()
        if w is not None:
            W = w[i_slice, None] * w[None, j_slice]
        else:
            W = None

        scores = self.score_model(X)
        loss = self.score_model.loss(X, Y, weights=W)

        # Search upper diagonal entries only
        # (note j_slice starting index is offset by one)
        scores = torch.triu(scores)

        # Filter by match type
        if is_match is not None:
            if is_match:
                scores *= Y
            else:
                scores *= (1 - Y)

        # Filter by min score
        if min_score is not None:
            scores *= (scores &gt;= min_score)

        # Filter by max score
        if max_score is not None:
            scores *= (scores &lt;= max_score)

        # Filter by min loss
        if min_loss is not None:
            scores *= (loss &gt;= min_loss)

        # Filter by max loss
        if max_loss is not None:
            scores *= (loss &lt;= max_loss)

        # Collect scored pairs
        i, j = torch.nonzero(scores, as_tuple=True)

        pairs = np.hstack([
            strings[i.cpu().numpy() + batch_start][:, None],
            strings[j.cpu().numpy() + (batch_start + 1)][:, None]
        ])

        pair_groups = np.hstack([
                                strings[group_ids[i + batch_start].cpu().numpy()][:, None],
                                strings[group_ids[j + (batch_start + 1)].cpu().numpy()][:, None]
                                ])

        pair_scores = scores[i, j].cpu().numpy()
        pair_losses = loss[i, j].cpu().numpy()

        return pairs, pair_groups, pair_scores, pair_losses

    def iter_scored_pairs(
            self,
            matcher=None,
            batch_size=64,
            progress_bar=True,
            **kwargs):
        &#34;&#34;&#34;
        A private method used to process and yield a batch of scored pairs of strings from the input matcher.

        :param matcher: a matcher objec
        :param batch_size: The number of pairs to score at a time, defaults to 64 (optional)
        :param progress_bar: Whether to show a progress bar, defaults to True (optional)
        :param kwargs: Additional keyword arguments to pass to the _batch_scored_pairs method.
        &#34;&#34;&#34;

        if matcher is not None:
            self = self.embed(matcher)
            group_ids = self._matcher_to_group_ids(matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        for batch_start in tqdm(
                range(
                    0,
                    len(self),
                    batch_size),
                desc=&#39;Scoring pairs&#39;,
                disable=not progress_bar):
            pairs, pair_groups, scores, losses = self._batch_scored_pairs(
                self, group_ids, batch_start, batch_size, **kwargs)
            for (s0, s1), (g0, g1), score, loss in zip(
                    pairs, pair_groups, scores, losses):
                yield {
                    &#39;string0&#39;: s0,
                    &#39;string1&#39;: s1,
                    &#39;group0&#39;: g0,
                    &#39;group1&#39;: g1,
                    &#39;score&#39;: score,
                    &#39;loss&#39;: loss,
                }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nama.embedding_similarity.load_similarity_model"><code class="name flex">
<span>def <span class="ident">load_similarity_model</span></span>(<span>model_file, map_location='cpu', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a similarity model from a saved model file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_file</code></strong> :&ensp;<code>str</code></dt>
<dd>the file to load the model from</dd>
<dt><strong><code>map_location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This is a string that specifies the device to load the model on, defaults to "cpu".</dd>
</dl>
<hr>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="nama.embedding_similarity.EmbeddingSimilarityModel" href="#nama.embedding_similarity.EmbeddingSimilarityModel">EmbeddingSimilarityModel</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<p>A similarity model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_similarity_model(model_file, map_location=&#39;cpu&#39;, **kwargs):
    &#34;&#34;&#34;
    Load a similarity model from a saved model file.

    Parameters
    ----------
    model_file : str
        the file to load the model from
    map_location : str, optional
        This is a string that specifies the device to load the model on, defaults to &#34;cpu&#34;.

    -------
    model: EmbeddingSimilarityModel
    A similarity model
    &#34;&#34;&#34;
    return torch.load(model_file, map_location=map_location, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel"><code class="flex name class">
<span>class <span class="ident">EmbeddingSimilarityModel</span></span>
<span>(</span><span>projector_class=nama.embedding_similarity.TransformerProjector, score_class=nama.embedding_similarity.ExpCosSimilarity, weighting_class=nama.embedding_similarity.ExponentWeights, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A combined projector/scorer model that produces Embeddings objects
as its primary output.</p>
<p>Initialize the EmbeddingSimilarityModel with the projector, score, and weighting models.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projector_class</code></strong> :&ensp;<code>The class</code> of <code>the projector model</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>score_class</code></strong> :&ensp;<code>the similarity function used to compare the projected query and projected document</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>weighting_class</code></strong> :&ensp;<code>This is the function that will be used to weight the scores</code> of <code>the different documents</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmbeddingSimilarityModel(nn.Module):
    &#34;&#34;&#34;
    A combined projector/scorer model that produces Embeddings objects
    as its primary output.
    &#34;&#34;&#34;
    # TODO add save for model hyper params

    def __init__(self,
                 projector_class=TransformerProjector,
                 score_class=ExpCosSimilarity,
                 weighting_class=ExponentWeights,
                 **kwargs):
        &#34;&#34;&#34;
        Initialize the EmbeddingSimilarityModel with the projector, score, and weighting models.

        Parameters
        ----------
        projector_class : The class of the projector model
        score_class : the similarity function used to compare the projected query and projected document
        weighting_class : This is the function that will be used to weight the scores of the different documents
        &#34;&#34;&#34;
        super().__init__()

        self.projector_model = projector_class(**kwargs)
        self.score_model = score_class(**kwargs)
        self.weighting_function = weighting_class(**kwargs)

        self.to(kwargs.get(&#39;device&#39;, &#39;cpu&#39;))

    def to(self, device):
        &#34;&#34;&#34;
        Moves the model to a specified device

        Parameters
        ----------
        device : the device to run the model on
        &#34;&#34;&#34;
        super().to(device)
        self.projector_model.to(device)
        self.score_model.to(device)
        self.device = device

    def save(self, savefile):
        &#34;&#34;&#34;
        Saves the model to a file.

        Parameters
        ----------
        savefile : the file to save the model to
        &#34;&#34;&#34;
        torch.save(self, savefile)

    def load_embeddings(self, f):
        &#34;&#34;&#34;
        Load embeddings from custom embedding archive format.

        Parameters
        ----------
        f : the file path to the embeddings
        &#34;&#34;&#34;
        raise NotImplementedError

        with ZipFile(f, &#39;r&#39;) as zip:
            score_model = pickle.loads(zip.read(&#39;score_model.pkl&#39;))
            weighting_function = pickle.loads(
                zip.read(&#39;weighting_function.pkl&#39;))
            strings_df = pd.read_csv(zip.open(&#39;strings.csv&#39;), na_filter=False)
            V = np.load(zip.open(&#39;V.npy&#39;))

            return Embeddings(
                strings=strings_df[&#39;string&#39;].values,
                counts=torch.tensor(strings_df[&#39;count&#39;].values),
                score_model=score_model,
                weighting_function=weighting_function,
                V=torch.tensor(V)
            )

    @torch.no_grad()
    def embed(
            self,
            input,
            to=None,
            batch_size=64,
            progress_bar=True,
            **kwargs):
        &#34;&#34;&#34;
        Construct an Embeddings object from input strings or a Matcher.

        Parameters
        ----------
        input : a list of strings or a Matcher object
        to : the device to put the embeddings on. If you&#39;re using a GPU, you&#39;ll want to put them on the GPU (optional)
        batch_size : The number of strings to embed at once, defaults to 64 (optional)
        progress_bar : Whether to show a progress bar, defaults to True (optional)

        Returns
        -------
        An Embeddings object.
        &#34;&#34;&#34;

        if to is None:
            to = self.device

        if isinstance(input, Matcher):
            strings = input.strings()
            counts = torch.tensor(
                [input.counts[s] for s in strings], device=self.device).float().to(to)

        else:
            strings = list(input)
            counts = torch.ones(
                len(strings),
                device=self.device).float().to(to)

        input_loader = DataLoader(
            strings, batch_size=batch_size, num_workers=0)

        self.projector_model.eval()

        V = None
        batch_start = 0
        with tqdm(total=len(strings), delay=1, desc=&#39;Embedding strings&#39;, disable=not progress_bar) as pbar:
            for batch_strings in input_loader:

                v = self.projector_model(batch_strings).detach().to(to)

                if V is None:
                    # Use v to determine dim and dtype of pre-allocated embedding tensor
                    # (Pre-allocating avoids duplicating tensors with a big .cat() operation)
                    V = torch.empty(
                        len(strings), v.shape[1], device=to, dtype=v.dtype)

                V[batch_start:batch_start + len(batch_strings), :] = v

                pbar.update(len(batch_strings))
                batch_start += len(batch_strings)

        score_model = copy(self.score_model)
        score_model.load_state_dict(self.score_model.state_dict())
        score_model.to(to)

        weighting_function = deepcopy(self.weighting_function)

        return Embeddings(strings=strings,
                          V=V.detach(),
                          counts=counts.detach(),
                          score_model=score_model,
                          weighting_function=weighting_function,
                          device=to)

    def train(
            self,
            training_matcher,
            max_epochs=1,
            batch_size=8,
            score_decay=0,
            regularization=0,
            transformer_lr=1e-5,
            projection_lr=1e-5,
            score_lr=10,
            warmup_frac=0.1,
            max_grad_norm=1,
            dropout=False,
            validation_matcher=None,
            target=&#39;F1&#39;,
            restore_best=True,
            val_seed=None,
            validation_interval=1000,
            early_stopping=True,
            early_stopping_patience=3,
            verbose=False,
            progress_bar=True,
            **kwargs):
        &#34;&#34;&#34;
        Trains the projector_model and score_model to predict match probabilities
        using the training_matcher as a source of &#34;correct&#34; matches.

        Training algorithm uses contrastive learning with hard-positive
        and hard-negative mining to fine tune the projector model to place
        matched strings near to each other in embedding space, while
        simultaneously calibrating the score_model to predict the match
        probabilities as a function of cosine distance

        Parameters
        ----------
        training_matcher : :class:`Matching`
            A Matching object with training data.
        max_epochs : int, optional (default=1)
            The number of epochs to train for.
        batch_size : int, optional (default=8)
            The number of strings to use in each training batch.
        score_decay : float, optional (default=0)
            A regularization parameter for the score model, similar to L2 regularization, but applied to the cosine distance between embeddings.
        regularization : float, optional (default=0)
        transformer_lr : float
            Learning rate for the transformer.
        projection_lr : float
            Learning rate for the projection layer.
        score_lr : float, optional (default=10)
            Learning rate for the score model.
        warmup_frac : float
            The fraction of training steps to use for the warm-up period.
        max_grad_norm : float, optional (default=1)
            The maximum gradient norm to clip to.
        dropout : bool, optional (default=False)
            Whether to use dropout in the transformer model.
        validation_matcher : :class:`Matching`, optional
            A matcher object used to evaluate the model during training.
        target : str, optional (default=&#39;F1&#39;)
            The metric to use for early stopping.
        restore_best : bool, optional (default=True)
            If True, the model will be restored to the state with the best validation score.
        val_seed : int, optional
            A random seed for validation, if desired.
        validation_interval : int, optional (default=1000)
            How often to run validation checks.
        early_stopping : bool, optional (default=True)
            If True, stop training if the validation score doesn&#39;t improve for `early_stopping_patience` epochs.
        early_stopping_patience : int, optional (default=3)
            How many validation checks to wait before stopping training.
        verbose : bool, optional (default=False)
            Print out the training progress, defaults to False (optional)
        progress_bar: bool
            Whether to show a progress bar during training, defaults to True (optional)

        Returns
        -------
        The return is a tuple of two dataframes. The first dataframe is the history of the
        training. The second dataframe is the validation scores.
        &#34;&#34;&#34;
        best_state = None
        if validation_matcher is None:
            early_stopping = False
            restore_best = False

        num_training_steps = max_epochs * len(training_matcher) // batch_size
        num_warmup_steps = int(warmup_frac * num_training_steps)

        if transformer_lr or projection_lr:
            embedding_optimizer = self.projector_model.config_optimizer(
                transformer_lr, projection_lr)
            embedding_scheduler = get_cosine_schedule_with_warmup(
                embedding_optimizer,
                num_warmup_steps=num_warmup_steps,
                num_training_steps=num_training_steps)
        if score_lr:
            score_optimizer = self.score_model.config_optimizer(score_lr)
            score_scheduler = get_linear_schedule_with_warmup(
                score_optimizer,
                num_warmup_steps=num_warmup_steps,
                num_training_steps=num_training_steps)

        step = 0
        self.history = []
        self.val_scores = []
        self.validation_scores = []
        for epoch in range(max_epochs):

            global_embeddings = self.embed(training_matcher)

            strings = global_embeddings.strings
            V = global_embeddings.V
            w = global_embeddings.w

            groups = torch.tensor(
                [global_embeddings.string_map[training_matcher[s]] for s in strings], device=self.device)

            # Normalize weights to make learning rates more general
            if w is not None:
                w = w / w.mean()

            shuffled_ids = list(range(len(strings)))
            random.shuffle(shuffled_ids)

            if dropout:
                self.projector_model.train()
            else:
                self.projector_model.eval()

            for batch_start in tqdm(
                    range(
                        0,
                        len(strings),
                        batch_size),
                    desc=f&#39;training epoch {epoch}&#39;,
                    disable=not progress_bar):

                h = {&#39;epoch&#39;: epoch, &#39;step&#39;: step}

                batch_i = shuffled_ids[batch_start:batch_start + batch_size]

                # Recycle ids from the beginning to pad the last batch if
                # necessary
                if len(batch_i) &lt; batch_size:
                    batch_i = batch_i + \
                        shuffled_ids[:(batch_size - len(batch_i))]

                &#34;&#34;&#34;
                Find highest loss match for each batch string (global search)

                Note: If we compute V_i with dropout enabled, it will add noise
                to the embeddings and prevent the same pairs from being selected
                every time.
                &#34;&#34;&#34;
                V_i = self.projector_model(strings[batch_i])

                # Update global embedding cache
                V[batch_i, :] = V_i.detach()

                with torch.no_grad():

                    global_X = V_i @ V.T
                    global_Y = (groups[batch_i][:, None]
                                == groups[None, :]).float()

                    if w is not None:
                        global_W = torch.outer(w[batch_i], w)
                    else:
                        global_W = None

                # Train scoring model only
                if score_lr:
                    # Make sure gradients are enabled for score model
                    self.score_model.requires_grad_(True)

                    global_loss = self.score_model.loss(
                        global_X, global_Y, weights=global_W, decay=score_decay)

                    score_optimizer.zero_grad()
                    global_loss.nanmean().backward()
                    torch.nn.utils.clip_grad_norm_(
                        self.score_model.parameters(), max_norm=max_grad_norm)

                    score_optimizer.step()
                    score_scheduler.step()

                    h[&#39;score_lr&#39;] = score_optimizer.param_groups[0][&#39;lr&#39;]
                    h[&#39;global_mean_cos&#39;] = global_X.mean().item()
                    try:
                        h[&#39;score_alpha&#39;] = self.score_model.alpha.item()
                    except BaseException:
                        pass

                else:
                    with torch.no_grad():
                        global_loss = self.score_model.loss(global_X, global_Y)

                h[&#39;global_loss&#39;] = global_loss.detach().nanmean().item()

                # Train projector model
                if (transformer_lr or projection_lr) and step &lt;= num_warmup_steps + \
                        num_training_steps:

                    # Turn off score model updating - only want to train
                    # projector here
                    self.score_model.requires_grad_(False)

                    # Select hard training examples
                    with torch.no_grad():
                        batch_j = global_loss.argmax(dim=1).flatten()

                        if w is not None:
                            batch_W = torch.outer(w[batch_i], w[batch_j])
                        else:
                            batch_W = None

                    # Train the model on the selected high-loss pairs
                    V_j = self.projector_model(strings[batch_j.tolist()])

                    # Update global embedding cache
                    V[batch_j, :] = V_j.detach()

                    batch_X = V_i @ V_j.T
                    batch_Y = (groups[batch_i][:, None] ==
                               groups[batch_j][None, :]).float()
                    h[&#39;batch_obs&#39;] = len(batch_i) * len(batch_j)

                    batch_loss = self.score_model.loss(
                        batch_X, batch_Y, weights=batch_W)

                    if regularization:
                        # Apply Global Orthogonal Regularization from
                        # https://arxiv.org/abs/1708.06320
                        gor_Y = (groups[batch_i][:, None] !=
                                 groups[batch_i][None, :]).float()
                        gor_n = gor_Y.sum()
                        if gor_n &gt; 1:
                            gor_X = (V_i @ V_i.T) * gor_Y
                            gor_m1 = 0.5 * gor_X.sum() / gor_n
                            gor_m2 = 0.5 * (gor_X**2).sum() / gor_n
                            batch_loss += regularization * \
                                (gor_m1 + torch.clamp(gor_m2 - 1 / self.projector_model.d, min=0))

                    h[&#39;batch_nan&#39;] = torch.isnan(
                        batch_loss.detach()).sum().item()

                    embedding_optimizer.zero_grad()
                    batch_loss.nanmean().backward()

                    torch.nn.utils.clip_grad_norm_(
                        self.parameters(), max_norm=max_grad_norm)

                    embedding_optimizer.step()
                    embedding_scheduler.step()

                    h[&#39;transformer_lr&#39;] = embedding_optimizer.param_groups[1][&#39;lr&#39;]
                    h[&#39;projection_lr&#39;] = embedding_optimizer.param_groups[-1][&#39;lr&#39;]

                    # Save stats
                    h[&#39;batch_loss&#39;] = batch_loss.detach().mean().item()
                    h[&#39;batch_pos_target&#39;] = batch_Y.detach().mean().item()

                self.history.append(h)
                step += 1

                if (validation_matcher is not None) and not (
                        step % validation_interval):
                    print(
                        f&#39;\nValidation results at step {step} (current epoch {epoch})&#39;)
                    validation = len(self.validation_scores)

                    with torch.no_grad():
                        val_scores = self.test(validation_matcher)

                        val_scores[&#39;step&#39;] = step - 1
                        val_scores[&#39;epoch&#39;] = epoch
                        val_scores[&#39;validation&#39;] = validation

                        if val_scores:
                            self.validation_scores.append(val_scores)

                    # Print validation stats
                    if verbose:
                        print(
                            f&#39;\nValidation results at step {step} (current epoch {epoch})&#39;)
                        for k, v in val_scores.items():
                            print(f&#39;    {k}: {v:.4f}&#39;)

                        print(list(self.score_model.named_parameters()))

                    # Update best saved model
                    if restore_best and best_state:
                        if val_scores[target] &gt;= max(
                                h[target] for h in self.validation_scores):
                            best_state = deepcopy({
                                &#39;state_dict&#39;: self.state_dict(),
                                &#39;val_scores&#39;: val_scores
                            })

                    if early_stopping and (
                            validation - best_state[&#39;val_scores&#39;][&#39;validation&#39;] &gt; early_stopping_patience):
                        print(
                            f&#39;Stopping training ({early_stopping_patience} validation checks since best validation score)&#39;)
                        break

        if restore_best:
            print(
                f&#34;Restoring to best state (step {best_state[&#39;val_scores&#39;][&#39;step&#39;]}):&#34;)
            for k, v in best_state[&#39;val_scores&#39;].items():
                print(f&#39;    {k}: {v:.4f}&#39;)

            self.to(&#39;cpu&#39;)
            self.load_state_dict(best_state[&#39;state_dict&#39;])
            self.to(self.device)

        return pd.DataFrame(self.history), pd.DataFrame(self.validation_scores)

    def predict(self, input, **kwargs):
        &#34;&#34;&#34;
        Predict the groupings for the given input.

        Parameters
        ----------
        input : Matcher
            the matcher to make the groupings predictions with
        **kwargs : dict
            Additional keyword arguments to pass the Embeddings.predict() function

        Returns
        -------
        Matcher
            An Matcher object containing the predicted groups
        &#34;&#34;&#34;
        embeddings = self.embed(input, **kwargs)
        return embeddings.predict(**kwargs)

    def test(self, gold_matcher, embed=None):
        &#34;&#34;&#34;
        Returns scores of predicted groupings vs the gold_matcher.

        Parameters
        ----------
        gold_matcher : Matcher
            The matcher compare the predictions with
        embed : Embeddings, optional
            The embeddings to use. If None, then the embeddings are generated from the gold_matcher

        Returns
        -------
        dict
            The scores of the predicted embeddings
        &#34;&#34;&#34;
        if not embed:
            embeddings = self.embed(gold_matcher, verbose=False)
        else:
            embeddings = embed

        predicted = embeddings.predict()

        scores = score_predicted(predicted, gold_matcher)

        return scores</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.embed"><code class="name flex">
<span>def <span class="ident">embed</span></span>(<span>self, input, to=None, batch_size=64, progress_bar=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an Embeddings object from input strings or a Matcher.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>a list</code> of <code>strings</code> or <code>a Matcher object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>the device to put the embeddings on. If you're using a GPU, you'll want to put them on the GPU (optional)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>The number</code> of <code>strings to embed at once, defaults to 64 (optional)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>progress_bar</code></strong> :&ensp;<code>Whether to show a progress bar, defaults to True (optional)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An Embeddings object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@torch.no_grad()
def embed(
        self,
        input,
        to=None,
        batch_size=64,
        progress_bar=True,
        **kwargs):
    &#34;&#34;&#34;
    Construct an Embeddings object from input strings or a Matcher.

    Parameters
    ----------
    input : a list of strings or a Matcher object
    to : the device to put the embeddings on. If you&#39;re using a GPU, you&#39;ll want to put them on the GPU (optional)
    batch_size : The number of strings to embed at once, defaults to 64 (optional)
    progress_bar : Whether to show a progress bar, defaults to True (optional)

    Returns
    -------
    An Embeddings object.
    &#34;&#34;&#34;

    if to is None:
        to = self.device

    if isinstance(input, Matcher):
        strings = input.strings()
        counts = torch.tensor(
            [input.counts[s] for s in strings], device=self.device).float().to(to)

    else:
        strings = list(input)
        counts = torch.ones(
            len(strings),
            device=self.device).float().to(to)

    input_loader = DataLoader(
        strings, batch_size=batch_size, num_workers=0)

    self.projector_model.eval()

    V = None
    batch_start = 0
    with tqdm(total=len(strings), delay=1, desc=&#39;Embedding strings&#39;, disable=not progress_bar) as pbar:
        for batch_strings in input_loader:

            v = self.projector_model(batch_strings).detach().to(to)

            if V is None:
                # Use v to determine dim and dtype of pre-allocated embedding tensor
                # (Pre-allocating avoids duplicating tensors with a big .cat() operation)
                V = torch.empty(
                    len(strings), v.shape[1], device=to, dtype=v.dtype)

            V[batch_start:batch_start + len(batch_strings), :] = v

            pbar.update(len(batch_strings))
            batch_start += len(batch_strings)

    score_model = copy(self.score_model)
    score_model.load_state_dict(self.score_model.state_dict())
    score_model.to(to)

    weighting_function = deepcopy(self.weighting_function)

    return Embeddings(strings=strings,
                      V=V.detach(),
                      counts=counts.detach(),
                      score_model=score_model,
                      weighting_function=weighting_function,
                      device=to)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, *input: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _forward_unimplemented(self, *input: Any) -&gt; None:
    r&#34;&#34;&#34;Defines the computation performed at every call.

    Should be overridden by all subclasses.

    .. note::
        Although the recipe for forward pass needs to be defined within
        this function, one should call the :class:`Module` instance afterwards
        instead of this since the former takes care of running the
        registered hooks while the latter silently ignores them.
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Module [{type(self).__name__}] is missing the required \&#34;forward\&#34; function&#34;)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.load_embeddings"><code class="name flex">
<span>def <span class="ident">load_embeddings</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Load embeddings from custom embedding archive format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>the file path to the embeddings</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_embeddings(self, f):
    &#34;&#34;&#34;
    Load embeddings from custom embedding archive format.

    Parameters
    ----------
    f : the file path to the embeddings
    &#34;&#34;&#34;
    raise NotImplementedError

    with ZipFile(f, &#39;r&#39;) as zip:
        score_model = pickle.loads(zip.read(&#39;score_model.pkl&#39;))
        weighting_function = pickle.loads(
            zip.read(&#39;weighting_function.pkl&#39;))
        strings_df = pd.read_csv(zip.open(&#39;strings.csv&#39;), na_filter=False)
        V = np.load(zip.open(&#39;V.npy&#39;))

        return Embeddings(
            strings=strings_df[&#39;string&#39;].values,
            counts=torch.tensor(strings_df[&#39;count&#39;].values),
            score_model=score_model,
            weighting_function=weighting_function,
            V=torch.tensor(V)
        )</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, input, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the groupings for the given input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>Matcher</code></dt>
<dd>the matcher to make the groupings predictions with</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional keyword arguments to pass the Embeddings.predict() function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Matcher</code></dt>
<dd>An Matcher object containing the predicted groups</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, input, **kwargs):
    &#34;&#34;&#34;
    Predict the groupings for the given input.

    Parameters
    ----------
    input : Matcher
        the matcher to make the groupings predictions with
    **kwargs : dict
        Additional keyword arguments to pass the Embeddings.predict() function

    Returns
    -------
    Matcher
        An Matcher object containing the predicted groups
    &#34;&#34;&#34;
    embeddings = self.embed(input, **kwargs)
    return embeddings.predict(**kwargs)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, savefile)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the model to a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>savefile</code></strong> :&ensp;<code>the file to save the model to</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, savefile):
    &#34;&#34;&#34;
    Saves the model to a file.

    Parameters
    ----------
    savefile : the file to save the model to
    &#34;&#34;&#34;
    torch.save(self, savefile)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, gold_matcher, embed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns scores of predicted groupings vs the gold_matcher.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gold_matcher</code></strong> :&ensp;<code>Matcher</code></dt>
<dd>The matcher compare the predictions with</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a title="nama.embedding_similarity.Embeddings" href="#nama.embedding_similarity.Embeddings">Embeddings</a></code>, optional</dt>
<dd>The embeddings to use. If None, then the embeddings are generated from the gold_matcher</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The scores of the predicted embeddings</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, gold_matcher, embed=None):
    &#34;&#34;&#34;
    Returns scores of predicted groupings vs the gold_matcher.

    Parameters
    ----------
    gold_matcher : Matcher
        The matcher compare the predictions with
    embed : Embeddings, optional
        The embeddings to use. If None, then the embeddings are generated from the gold_matcher

    Returns
    -------
    dict
        The scores of the predicted embeddings
    &#34;&#34;&#34;
    if not embed:
        embeddings = self.embed(gold_matcher, verbose=False)
    else:
        embeddings = embed

    predicted = embeddings.predict()

    scores = score_predicted(predicted, gold_matcher)

    return scores</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.to"><code class="name flex">
<span>def <span class="ident">to</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the model to a specified device</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device</code></strong> :&ensp;<code>the device to run the model on</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to(self, device):
    &#34;&#34;&#34;
    Moves the model to a specified device

    Parameters
    ----------
    device : the device to run the model on
    &#34;&#34;&#34;
    super().to(device)
    self.projector_model.to(device)
    self.score_model.to(device)
    self.device = device</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.EmbeddingSimilarityModel.train"><code class="name flex">
<span>def <span class="ident">train</span></span>(<span>self, training_matcher, max_epochs=1, batch_size=8, score_decay=0, regularization=0, transformer_lr=1e-05, projection_lr=1e-05, score_lr=10, warmup_frac=0.1, max_grad_norm=1, dropout=False, validation_matcher=None, target='F1', restore_best=True, val_seed=None, validation_interval=1000, early_stopping=True, early_stopping_patience=3, verbose=False, progress_bar=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Trains the projector_model and score_model to predict match probabilities
using the training_matcher as a source of "correct" matches.</p>
<p>Training algorithm uses contrastive learning with hard-positive
and hard-negative mining to fine tune the projector model to place
matched strings near to each other in embedding space, while
simultaneously calibrating the score_model to predict the match
probabilities as a function of cosine distance</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>training_matcher</code></strong> :&ensp;<code>:class:</code>Matching``</dt>
<dd>A Matching object with training data.</dd>
<dt><strong><code>max_epochs</code></strong> :&ensp;<code>int</code>, optional <code>(default=1)</code></dt>
<dd>The number of epochs to train for.</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code>, optional <code>(default=8)</code></dt>
<dd>The number of strings to use in each training batch.</dd>
<dt><strong><code>score_decay</code></strong> :&ensp;<code>float</code>, optional <code>(default=0)</code></dt>
<dd>A regularization parameter for the score model, similar to L2 regularization, but applied to the cosine distance between embeddings.</dd>
<dt><strong><code>regularization</code></strong> :&ensp;<code>float</code>, optional <code>(default=0)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>transformer_lr</code></strong> :&ensp;<code>float</code></dt>
<dd>Learning rate for the transformer.</dd>
<dt><strong><code>projection_lr</code></strong> :&ensp;<code>float</code></dt>
<dd>Learning rate for the projection layer.</dd>
<dt><strong><code>score_lr</code></strong> :&ensp;<code>float</code>, optional <code>(default=10)</code></dt>
<dd>Learning rate for the score model.</dd>
<dt><strong><code>warmup_frac</code></strong> :&ensp;<code>float</code></dt>
<dd>The fraction of training steps to use for the warm-up period.</dd>
<dt><strong><code>max_grad_norm</code></strong> :&ensp;<code>float</code>, optional <code>(default=1)</code></dt>
<dd>The maximum gradient norm to clip to.</dd>
<dt><strong><code>dropout</code></strong> :&ensp;<code>bool</code>, optional <code>(default=False)</code></dt>
<dd>Whether to use dropout in the transformer model.</dd>
<dt><strong><code>validation_matcher</code></strong> :&ensp;<code>:class:</code>Matching``, optional</dt>
<dd>A matcher object used to evaluate the model during training.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code>, optional <code>(default='F1')</code></dt>
<dd>The metric to use for early stopping.</dd>
<dt><strong><code>restore_best</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>If True, the model will be restored to the state with the best validation score.</dd>
<dt><strong><code>val_seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>A random seed for validation, if desired.</dd>
<dt><strong><code>validation_interval</code></strong> :&ensp;<code>int</code>, optional <code>(default=1000)</code></dt>
<dd>How often to run validation checks.</dd>
<dt><strong><code>early_stopping</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>If True, stop training if the validation score doesn't improve for <code>early_stopping_patience</code> epochs.</dd>
<dt><strong><code>early_stopping_patience</code></strong> :&ensp;<code>int</code>, optional <code>(default=3)</code></dt>
<dd>How many validation checks to wait before stopping training.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional <code>(default=False)</code></dt>
<dd>Print out the training progress, defaults to False (optional)</dd>
<dt><strong><code>progress_bar</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show a progress bar during training, defaults to True (optional)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The return is a tuple</code> of <code>two dataframes. The first dataframe is the history</code> of <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>training. The second dataframe is the validation scores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train(
        self,
        training_matcher,
        max_epochs=1,
        batch_size=8,
        score_decay=0,
        regularization=0,
        transformer_lr=1e-5,
        projection_lr=1e-5,
        score_lr=10,
        warmup_frac=0.1,
        max_grad_norm=1,
        dropout=False,
        validation_matcher=None,
        target=&#39;F1&#39;,
        restore_best=True,
        val_seed=None,
        validation_interval=1000,
        early_stopping=True,
        early_stopping_patience=3,
        verbose=False,
        progress_bar=True,
        **kwargs):
    &#34;&#34;&#34;
    Trains the projector_model and score_model to predict match probabilities
    using the training_matcher as a source of &#34;correct&#34; matches.

    Training algorithm uses contrastive learning with hard-positive
    and hard-negative mining to fine tune the projector model to place
    matched strings near to each other in embedding space, while
    simultaneously calibrating the score_model to predict the match
    probabilities as a function of cosine distance

    Parameters
    ----------
    training_matcher : :class:`Matching`
        A Matching object with training data.
    max_epochs : int, optional (default=1)
        The number of epochs to train for.
    batch_size : int, optional (default=8)
        The number of strings to use in each training batch.
    score_decay : float, optional (default=0)
        A regularization parameter for the score model, similar to L2 regularization, but applied to the cosine distance between embeddings.
    regularization : float, optional (default=0)
    transformer_lr : float
        Learning rate for the transformer.
    projection_lr : float
        Learning rate for the projection layer.
    score_lr : float, optional (default=10)
        Learning rate for the score model.
    warmup_frac : float
        The fraction of training steps to use for the warm-up period.
    max_grad_norm : float, optional (default=1)
        The maximum gradient norm to clip to.
    dropout : bool, optional (default=False)
        Whether to use dropout in the transformer model.
    validation_matcher : :class:`Matching`, optional
        A matcher object used to evaluate the model during training.
    target : str, optional (default=&#39;F1&#39;)
        The metric to use for early stopping.
    restore_best : bool, optional (default=True)
        If True, the model will be restored to the state with the best validation score.
    val_seed : int, optional
        A random seed for validation, if desired.
    validation_interval : int, optional (default=1000)
        How often to run validation checks.
    early_stopping : bool, optional (default=True)
        If True, stop training if the validation score doesn&#39;t improve for `early_stopping_patience` epochs.
    early_stopping_patience : int, optional (default=3)
        How many validation checks to wait before stopping training.
    verbose : bool, optional (default=False)
        Print out the training progress, defaults to False (optional)
    progress_bar: bool
        Whether to show a progress bar during training, defaults to True (optional)

    Returns
    -------
    The return is a tuple of two dataframes. The first dataframe is the history of the
    training. The second dataframe is the validation scores.
    &#34;&#34;&#34;
    best_state = None
    if validation_matcher is None:
        early_stopping = False
        restore_best = False

    num_training_steps = max_epochs * len(training_matcher) // batch_size
    num_warmup_steps = int(warmup_frac * num_training_steps)

    if transformer_lr or projection_lr:
        embedding_optimizer = self.projector_model.config_optimizer(
            transformer_lr, projection_lr)
        embedding_scheduler = get_cosine_schedule_with_warmup(
            embedding_optimizer,
            num_warmup_steps=num_warmup_steps,
            num_training_steps=num_training_steps)
    if score_lr:
        score_optimizer = self.score_model.config_optimizer(score_lr)
        score_scheduler = get_linear_schedule_with_warmup(
            score_optimizer,
            num_warmup_steps=num_warmup_steps,
            num_training_steps=num_training_steps)

    step = 0
    self.history = []
    self.val_scores = []
    self.validation_scores = []
    for epoch in range(max_epochs):

        global_embeddings = self.embed(training_matcher)

        strings = global_embeddings.strings
        V = global_embeddings.V
        w = global_embeddings.w

        groups = torch.tensor(
            [global_embeddings.string_map[training_matcher[s]] for s in strings], device=self.device)

        # Normalize weights to make learning rates more general
        if w is not None:
            w = w / w.mean()

        shuffled_ids = list(range(len(strings)))
        random.shuffle(shuffled_ids)

        if dropout:
            self.projector_model.train()
        else:
            self.projector_model.eval()

        for batch_start in tqdm(
                range(
                    0,
                    len(strings),
                    batch_size),
                desc=f&#39;training epoch {epoch}&#39;,
                disable=not progress_bar):

            h = {&#39;epoch&#39;: epoch, &#39;step&#39;: step}

            batch_i = shuffled_ids[batch_start:batch_start + batch_size]

            # Recycle ids from the beginning to pad the last batch if
            # necessary
            if len(batch_i) &lt; batch_size:
                batch_i = batch_i + \
                    shuffled_ids[:(batch_size - len(batch_i))]

            &#34;&#34;&#34;
            Find highest loss match for each batch string (global search)

            Note: If we compute V_i with dropout enabled, it will add noise
            to the embeddings and prevent the same pairs from being selected
            every time.
            &#34;&#34;&#34;
            V_i = self.projector_model(strings[batch_i])

            # Update global embedding cache
            V[batch_i, :] = V_i.detach()

            with torch.no_grad():

                global_X = V_i @ V.T
                global_Y = (groups[batch_i][:, None]
                            == groups[None, :]).float()

                if w is not None:
                    global_W = torch.outer(w[batch_i], w)
                else:
                    global_W = None

            # Train scoring model only
            if score_lr:
                # Make sure gradients are enabled for score model
                self.score_model.requires_grad_(True)

                global_loss = self.score_model.loss(
                    global_X, global_Y, weights=global_W, decay=score_decay)

                score_optimizer.zero_grad()
                global_loss.nanmean().backward()
                torch.nn.utils.clip_grad_norm_(
                    self.score_model.parameters(), max_norm=max_grad_norm)

                score_optimizer.step()
                score_scheduler.step()

                h[&#39;score_lr&#39;] = score_optimizer.param_groups[0][&#39;lr&#39;]
                h[&#39;global_mean_cos&#39;] = global_X.mean().item()
                try:
                    h[&#39;score_alpha&#39;] = self.score_model.alpha.item()
                except BaseException:
                    pass

            else:
                with torch.no_grad():
                    global_loss = self.score_model.loss(global_X, global_Y)

            h[&#39;global_loss&#39;] = global_loss.detach().nanmean().item()

            # Train projector model
            if (transformer_lr or projection_lr) and step &lt;= num_warmup_steps + \
                    num_training_steps:

                # Turn off score model updating - only want to train
                # projector here
                self.score_model.requires_grad_(False)

                # Select hard training examples
                with torch.no_grad():
                    batch_j = global_loss.argmax(dim=1).flatten()

                    if w is not None:
                        batch_W = torch.outer(w[batch_i], w[batch_j])
                    else:
                        batch_W = None

                # Train the model on the selected high-loss pairs
                V_j = self.projector_model(strings[batch_j.tolist()])

                # Update global embedding cache
                V[batch_j, :] = V_j.detach()

                batch_X = V_i @ V_j.T
                batch_Y = (groups[batch_i][:, None] ==
                           groups[batch_j][None, :]).float()
                h[&#39;batch_obs&#39;] = len(batch_i) * len(batch_j)

                batch_loss = self.score_model.loss(
                    batch_X, batch_Y, weights=batch_W)

                if regularization:
                    # Apply Global Orthogonal Regularization from
                    # https://arxiv.org/abs/1708.06320
                    gor_Y = (groups[batch_i][:, None] !=
                             groups[batch_i][None, :]).float()
                    gor_n = gor_Y.sum()
                    if gor_n &gt; 1:
                        gor_X = (V_i @ V_i.T) * gor_Y
                        gor_m1 = 0.5 * gor_X.sum() / gor_n
                        gor_m2 = 0.5 * (gor_X**2).sum() / gor_n
                        batch_loss += regularization * \
                            (gor_m1 + torch.clamp(gor_m2 - 1 / self.projector_model.d, min=0))

                h[&#39;batch_nan&#39;] = torch.isnan(
                    batch_loss.detach()).sum().item()

                embedding_optimizer.zero_grad()
                batch_loss.nanmean().backward()

                torch.nn.utils.clip_grad_norm_(
                    self.parameters(), max_norm=max_grad_norm)

                embedding_optimizer.step()
                embedding_scheduler.step()

                h[&#39;transformer_lr&#39;] = embedding_optimizer.param_groups[1][&#39;lr&#39;]
                h[&#39;projection_lr&#39;] = embedding_optimizer.param_groups[-1][&#39;lr&#39;]

                # Save stats
                h[&#39;batch_loss&#39;] = batch_loss.detach().mean().item()
                h[&#39;batch_pos_target&#39;] = batch_Y.detach().mean().item()

            self.history.append(h)
            step += 1

            if (validation_matcher is not None) and not (
                    step % validation_interval):
                print(
                    f&#39;\nValidation results at step {step} (current epoch {epoch})&#39;)
                validation = len(self.validation_scores)

                with torch.no_grad():
                    val_scores = self.test(validation_matcher)

                    val_scores[&#39;step&#39;] = step - 1
                    val_scores[&#39;epoch&#39;] = epoch
                    val_scores[&#39;validation&#39;] = validation

                    if val_scores:
                        self.validation_scores.append(val_scores)

                # Print validation stats
                if verbose:
                    print(
                        f&#39;\nValidation results at step {step} (current epoch {epoch})&#39;)
                    for k, v in val_scores.items():
                        print(f&#39;    {k}: {v:.4f}&#39;)

                    print(list(self.score_model.named_parameters()))

                # Update best saved model
                if restore_best and best_state:
                    if val_scores[target] &gt;= max(
                            h[target] for h in self.validation_scores):
                        best_state = deepcopy({
                            &#39;state_dict&#39;: self.state_dict(),
                            &#39;val_scores&#39;: val_scores
                        })

                if early_stopping and (
                        validation - best_state[&#39;val_scores&#39;][&#39;validation&#39;] &gt; early_stopping_patience):
                    print(
                        f&#39;Stopping training ({early_stopping_patience} validation checks since best validation score)&#39;)
                    break

    if restore_best:
        print(
            f&#34;Restoring to best state (step {best_state[&#39;val_scores&#39;][&#39;step&#39;]}):&#34;)
        for k, v in best_state[&#39;val_scores&#39;].items():
            print(f&#39;    {k}: {v:.4f}&#39;)

        self.to(&#39;cpu&#39;)
        self.load_state_dict(best_state[&#39;state_dict&#39;])
        self.to(self.device)

    return pd.DataFrame(self.history), pd.DataFrame(self.validation_scores)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nama.embedding_similarity.Embeddings"><code class="flex name class">
<span>class <span class="ident">Embeddings</span></span>
<span>(</span><span>strings, V, score_model, weighting_function, counts, device='cpu')</span>
</code></dt>
<dd>
<div class="desc"><p>Stores embeddings for a fixed array of strings and provides methods for
clustering the strings to create Matcher objects according to different
algorithms.</p>
<p>Initialize the Embeddings object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strings</code></strong> :&ensp;<code>list</code></dt>
<dd>List of strings that we want to be able to score.</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the vocabulary.</dd>
<dt><strong><code>score_model</code></strong> :&ensp;<code>function</code></dt>
<dd>A function that takes in a string and returns a score.</dd>
<dt><strong><code>weighting_function</code></strong> :&ensp;<code>function</code></dt>
<dd>A function that takes a list of counts and returns a list of weights.</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of counts of each string in the vocabulary.</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>str</code></dt>
<dd>The device to run the model on. Default: 'cpu'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Embeddings(nn.Module):
    &#34;&#34;&#34;
    Stores embeddings for a fixed array of strings and provides methods for
    clustering the strings to create Matcher objects according to different
    algorithms.
    &#34;&#34;&#34;

    def __init__(
            self,
            strings,
            V,
            score_model,
            weighting_function,
            counts,
            device=&#39;cpu&#39;):
        &#34;&#34;&#34;
        Initialize the Embeddings object.

        Parameters
        ----------
        strings : list
            List of strings that we want to be able to score.
        V : int
            The size of the vocabulary.
        score_model : function
            A function that takes in a string and returns a score.
        weighting_function : function
            A function that takes a list of counts and returns a list of weights.
        counts : dict
            Dictionary of counts of each string in the vocabulary.
        device : str
            The device to run the model on. Default: &#39;cpu&#39;

        &#34;&#34;&#34;
        super().__init__()

        self.strings = np.array(list(strings))
        self.string_map = {s: i for i, s in enumerate(strings)}
        self.V = V
        self.counts = counts
        self.w = weighting_function(counts)
        self.score_model = score_model
        self.weighting_function = weighting_function
        self.device = device

        self.to(device)

    def __repr__(self):
        &#34;&#34;&#34;Return a string representation of the Embeddings object&#34;&#34;&#34;
        return f&#39;&lt;nama.Embeddings containing {self.V.shape[1]}-d vectors for {len(self)} strings&#39;

    def to(self, device):
        &#34;&#34;&#34;
        Moves the model to a specified device.

        Parameters
        ----------
        device : str
            The device to run the model on.
        &#34;&#34;&#34;
        super().to(device)
        self.V = self.V.to(device)
        self.counts = self.counts.to(device)
        self.w = self.w.to(device)
        self.score_model.to(device)
        self.device = device

    def save(self, f):
        &#34;&#34;&#34;
        Saves the embedding vectors, score model, weighting function, and strings and counts to an archive format.

        Parameters
        ----------
        f : str
            The file to save to.
        &#34;&#34;&#34;
        with ZipFile(f, &#39;w&#39;) as zip:

            # Write score model
            zip.writestr(&#39;score_model.pkl&#39;, pickle.dumps(self.score_model))

            # Write score model
            zip.writestr(
                &#39;weighting_function.pkl&#39;,
                pickle.dumps(
                    self.weighting_function))

            # Write string info
            strings_df = pd.DataFrame().assign(
                string=self.strings,
                count=self.counts.to(&#39;cpu&#39;).numpy())
            zip.writestr(&#39;strings.csv&#39;, strings_df.to_csv(index=False))

            # Write embedding vectors
            byte_io = BytesIO()
            np.save(byte_io, self.V.to(&#39;cpu&#39;).numpy(), allow_pickle=False)
            zip.writestr(&#39;V.npy&#39;, byte_io.getvalue())

    def __getitem__(self, arg):
        &#34;&#34;&#34;
        Slices the embeddings and its matcher, and returns a new embedding with the same properties as the original, but with the slice applied.

        Parameters
        ----------
        arg : slice or Matcher or iter
            Slice of the Embeddings. Can be type `slice`, `Matcher` or `iter`.

        Returns
        -------
        Embedding
            A new `Embedding` object with the same attributes as the original, but with the strings, `V`, counts, `w`, and `string_map` attributes sliced according to the input.
        &#34;&#34;&#34;
        if isinstance(arg, slice):
            i = arg
        elif isinstance(arg, Matcher):
            return self[arg.strings()]
        elif hasattr(arg, &#39;__iter__&#39;):
            # Return a subset of the embeddings and their weights
            string_map = self.string_map
            i = [string_map[s] for s in arg]

            if i == list(range(len(self))):
                # Just selecting the whole matcher - no need to slice the
                # embedding
                return copy(self)
        else:
            raise ValueError(
                f&#39;Unknown slice input type ({type(input)}). Can only slice Embedding with a slice, matcher, or iterable.&#39;)

        new = copy(self)
        new.strings = self.strings[i]
        new.V = self.V[i]
        new.counts = self.counts[i]
        new.w = self.w[i]
        new.string_map = {s: i for i, s in enumerate(new.strings)}

        return new

    def embed(self, matcher):
        &#34;&#34;&#34;
        Constructs an updated `Embeddings` object with counts from the input Matcher.

        Parameters
        ----------
        matcher : Matcher
            A `Matcher` object.

        Returns
        -------
        Embeddings
            A new `Embeddings` object with updated counts and weights.
        &#34;&#34;&#34;
        new = self[matcher]
        new.counts = torch.tensor([matcher.counts[s]
                                  for s in new.strings], device=self.device)
        new.w = new.weighting_function(new.counts)

        return new

    def __len__(self):
        &#34;&#34;&#34;
        Returns:
            int: Number of strings stored in the Embeddings object.
        &#34;&#34;&#34;
        return len(self.strings)

    def _matcher_to_group_ids(self, matcher):
        &#34;&#34;&#34;
        Convert a Matcher object to group IDs.

        Args:
            matcher: compiled regex object

        Returns:
            list of str: A list of strings
        &#34;&#34;&#34;
        group_id_map = {g: i for i, g in enumerate(matcher.groups.keys())}
        group_ids = torch.tensor([group_id_map[matcher[s]]
                                 for s in self.strings]).to(self.device)
        return group_ids

    def _group_ids_to_matcher(self, group_ids):
        &#34;&#34;&#34;
        Convert group IDs to a Matcher object.

        Args:
            group_ids: A tensor of group ids

        Returns:
            Matcher: A matcher object
        &#34;&#34;&#34;
        if isinstance(group_ids, torch.Tensor):
            group_ids = group_ids.to(&#39;cpu&#39;).numpy()

        strings = self.strings
        counts = self.counts.to(&#39;cpu&#39;).numpy()

        # Sort by group and string count
        g_sort = np.lexsort((counts, group_ids))
        group_ids = group_ids[g_sort]
        strings = strings[g_sort]
        counts = counts[g_sort]

        # Identify group boundaries and split locations
        split_locs = np.nonzero(group_ids[1:] != group_ids[:-1])[0] + 1

        # Get grouped strings as separate arrays
        groups = np.split(strings, split_locs)

        # Build the matcher
        matcher = Matcher()
        matcher.counts = Counter({s: int(c) for s, c in zip(strings, counts)})
        matcher.labels = {s: g[-1] for g in groups for s in g}
        matcher.groups = {g[-1]: list(g) for g in groups}

        return matcher

    @torch.no_grad()
    def _fast_predict(
            self,
            threshold=0.5,
            base_matcher=None,
            progress_bar=True,
            batch_size=64):
        &#34;&#34;&#34;
        For each embedding, find all embeddings that are similar to it and assign them to the same group.

        Parameters
        ----------
        threshold : float
            The threshold for the jaccard score.
        base_matcher : Matcher, optional
            A matcher object that has already been run on the embeddings. This is used to speed up the matching process.
        progress_bar : bool, optional
            Whether to show a progress bar, defaults to True.
        batch_size : int, optional
            The number of embeddings to process at once, defaults to 64.

        Returns
        -------
        Matcher
        A matcher object.
        &#34;&#34;&#34;
        if base_matcher is not None:
            # self = self.embed(base_matcher)
            group_ids = self._matcher_to_group_ids(base_matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        V = self.V
        cos_threshold = self.score_model.score_to_cos(threshold)

        for batch_start in tqdm(
                range(
                    0,
                    len(self),
                    batch_size),
                delay=1,
                desc=&#39;Predicting matches&#39;,
                disable=not progress_bar):

            i_slice = slice(batch_start, batch_start + batch_size)
            j_slice = slice(batch_start + 1, None)

            g_i = group_ids[i_slice]
            g_j = group_ids[j_slice]

            # Find j&#39;s with jaccard &gt; threshold (&#34;matches&#34;)
            batch_matched = (V[i_slice] @ V[j_slice].T &gt;= cos_threshold) \
                * (g_i[:, None] != g_j[None, :])

            for k, matched in enumerate(batch_matched):
                if matched.any():
                    # Get the group ids of the matched j&#39;s
                    matched_groups = g_j[matched]

                    # Identify all embeddings in these groups
                    ids_to_group = torch.isin(group_ids, matched_groups)

                    # Assign all matched embeddings to the same group
                    group_ids[ids_to_group] = g_i[k].clone()

        return self._group_ids_to_matcher(group_ids)

    @torch.no_grad()
    def predict(self,
                threshold=0.5,
                group_threshold=None,
                separate_strings=[],
                base_matcher=None,
                batch_size=64,
                progress_bar=True):
        &#34;&#34;&#34;
        Unite embedding strings according to predicted pairwise similarity.

        - &#34;base_matcher&#34; will be used to inialize the group_ids before uniting new matches
        - &#34;theshold&#34; sets the minimimum match similarity required to unite two strings.
            - Note that strings with similarity&lt;threshold can end up matched if they are
              linked by a chain of sufficiently similar strings (matching is transitive).
              &#34;group_threshold&#34; can be used to add an additional constraing on the minimum
              similarity within each group.
        - &#34;group_threshold&#34; sets the minimum similarity required within a single group.
          If &#34;group_threshold&#34; != None, string pairs with similarity&gt;threshold are identified
          and stored in order of similarity. Highest similarity strings are matched first,
          and before each time a pair of strings is united, the function checks if this will
          result in grouping any two strings with similarity&lt;group_threshold. If so, this pair
          is skipped. This version of the algorithm is slower than the one used when
          &#34;group_threshold=None.
        - &#34;separate_strings&#34; takes a list of strings that should never be united with each
          other (these strings will still be united with other strings)

        :param threshold: The minimum similarity required to unite two strings
        :param group_threshold: the minimum similarity required within a single group
        :param separate_strings: a list of strings that should never be united with each other (these
        strings will still be united with other strings)
        :param base_matcher: This is a matcher object that you can use to initialize the group_ids before
        uniting new matches
        :param batch_size: The number of embeddings to process at once, defaults to 64 (optional)
        :param progress_bar: Whether to show a progress bar, defaults to True (optional)
        :return: A Matcher object
        &#34;&#34;&#34;

        # Use the faster prediction algorithm if possible
        if not (group_threshold or separate_strings):

            return self._fast_predict(
                threshold=threshold,
                base_matcher=base_matcher,
                batch_size=batch_size,
                progress_bar=progress_bar)

        if base_matcher is not None:
            # self = self.embed(base_matcher)
            group_ids = self._matcher_to_group_ids(base_matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        V = self.V
        cos_threshold = self.score_model.score_to_cos(threshold)
        if group_threshold is not None:
            separate_cos = self.score_model.score_to_cos(group_threshold)

        # First collect all pairs to match (can be memory intensive!)
        matches = []
        cos_scores = []
        for batch_start in tqdm(range(0, len(self), batch_size),
                                desc=&#39;Scoring pairs&#39;,
                                delay=1, disable=not progress_bar):

            i_slice = slice(batch_start, batch_start + batch_size)
            j_slice = slice(batch_start + 1, None)

            # Find j&#39;s with jaccard &gt; threshold (&#34;matches&#34;)
            batch_cos = V[i_slice] @ V[j_slice].T

            # Search upper diagonal entries only
            # (note j_slice starting index is offset by one)
            batch_cos = torch.triu(batch_cos)

            bi, bj = torch.nonzero(batch_cos &gt;= cos_threshold, as_tuple=True)

            if len(bi):
                # Convert batch index locations to global index locations
                i = bi + batch_start
                j = bj + batch_start + 1

                cos = batch_cos[bi, bj]

                # Can skip strings that are already matched in the base matcher
                unmatched = group_ids[i] != group_ids[j]
                i = i[unmatched]
                j = j[unmatched]
                cos = cos[unmatched]

                if len(i):
                    batch_matches = torch.hstack([i[:, None], j[:, None]])

                    matches.append(batch_matches.to(&#39;cpu&#39;).numpy())
                    cos_scores.append(cos.to(&#39;cpu&#39;).numpy())

        # Then unite the pairs in priority order, checking for violations of the
        # separation arguments
        if matches:
            matches = np.vstack(matches)
            cos_scores = np.hstack(cos_scores).T

            # Sort matches in descending order of score
            m_sort = cos_scores.argsort()[::-1]
            matches = matches[m_sort]

            # Set up tensors
            matches = torch.tensor(matches).to(self.device)
            separate_strings = set(separate_strings)
            separated = torch.tensor(
                [s in separate_strings for s in self.strings]).to(self.device)

            n_matches = matches.shape[0]
            with tqdm(total=n_matches, desc=&#39;Uniting matches&#39;,
                      delay=1, disable=not progress_bar) as p_bar:

                while len(matches):

                    # Select the current match pair and remove it from the
                    # queue
                    match_pair = matches[0]
                    matches = matches[1:]

                    # Get the groups of the current match pair
                    g = group_ids[match_pair]

                    # Identify which strings should be united
                    to_unite = (group_ids == g[0]) | (group_ids == g[1])

                    # Flag whether uniting this pair will unite any separated
                    # strings
                    any_separated = separated[to_unite].sum() &gt; 1

                    # Flag whether the new group will have three or more
                    # strings
                    singletons = to_unite.sum() &lt; 3

                    if any_separated:
                        unite_ok = False
                    else:
                        if singletons:
                            unite_ok = True
                        else:
                            if group_threshold is None:
                                unite_ok = True
                            else:
                                V0 = V[group_ids == g[0], :]
                                V1 = V[group_ids == g[1], :]

                                unite_ok = (V0 @ V1.T).min() &gt;= separate_cos

                    if unite_ok:

                        # Unite groups
                        group_ids[to_unite] = g[0]

                        # If we are uniting more than two strings, we can eliminate
                        # some redundant matches in the queue
                        if not singletons:
                            # Removed queued matches that are now in the same
                            # group
                            matches = matches[group_ids[matches[:, 0]]
                                              != group_ids[matches[:, 1]]]
                    else:
                        # Remove queued matches connecting these groups
                        matches = matches[torch.isin(group_ids[matches[:, 0]], g, invert=True)
                                          | torch.isin(group_ids[matches[:, 1]], g, invert=True)]

                    # Update progress bar
                    p_bar.update(n_matches - matches.shape[0])
                    n_matches = matches.shape[0]

        return self._group_ids_to_matcher(group_ids)

    @torch.no_grad()
    def voronoi(
            self,
            seed_strings,
            threshold=0,
            base_matcher=None,
            progress_bar=True,
            batch_size=64):
        &#34;&#34;&#34;
        Unite embedding strings with each string&#39;s most similar seed string.

        - &#34;base_matcher&#34; will be used to inialize the group_ids before uniting new matches
        - &#34;theshold&#34; sets the minimimum match similarity required between a string and seed string
          for the string to be matched. (i.e., setting theshold=0 will result in every embedding
          string to be matched its nearest seed string, while setting threshold=0.9 will leave
          strings that have similarity&lt;0.9 with their nearest seed string unaffected)

        returns: Matcher object

        :param seed_strings: a list of strings to use as seed strings
        :param threshold: The minimum similarity score required for a match, defaults to 0 (optional)
        :param base_matcher: The matcher object to use as a starting point. If None, then the embedding
        strings will be used as the starting point
        :param progress_bar: Whether to show a progress bar, defaults to True (optional)
        :param batch_size: The number of embedding strings to process at a time, defaults to 64
        (optional)
        &#34;&#34;&#34;

        if base_matcher is not None:
            # self = self.embed(base_matcher)
            group_ids = self._matcher_to_group_ids(base_matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        V = self.V
        cos_threshold = self.score_model.score_to_cos(threshold)

        seed_ids = torch.tensor([self.string_map[s]
                                for s in seed_strings]).to(self.device)
        V_seed = V[seed_ids]
        g_seed = group_ids[seed_ids]
        is_seed = torch.zeros(V.shape[0], dtype=torch.bool).to(self.device)
        is_seed[g_seed] = True

        for batch_start in tqdm(
                range(
                    0,
                    len(self),
                    batch_size),
                delay=1,
                desc=&#39;Predicting matches&#39;,
                disable=not progress_bar):

            batch_slice = slice(batch_start, batch_start + batch_size)

            batch_cos = V[batch_slice] @ V_seed.T

            max_cos, max_seed = torch.max(batch_cos, dim=1)

            # Get batch index locations where score &gt; threshold
            batch_i = torch.nonzero(max_cos &gt; cos_threshold)

            if len(batch_i):
                # Drop seed strings from matches (otherwise numerical precision
                # issues can allow seed strings to match to other strings)
                batch_i = batch_i[~is_seed[batch_slice][batch_i]]

                if len(batch_i):
                    # Get indices of matched strings
                    i = batch_i + batch_start

                    # Assign matched strings to the seed string&#39;s group
                    group_ids[i] = g_seed[max_seed[batch_i]]

        return self._group_ids_to_matcher(group_ids)

    @torch.no_grad()
    def _batch_scored_pairs(self, group_ids, batch_start, batch_size,
                            is_match=None,
                            min_score=None, max_score=None,
                            min_loss=None, max_loss=None):
        &#34;&#34;&#34;
        A private method used to compute the scored pairs within a batch. Computes the scores and losses for all pairs of strings in the batch,
        and returns the pairs, their scores, and their losses

        :param group_ids: The group ids of the strings in the batch
        :param batch_start: the index of the first string in the batch
        :param batch_size: The number of pairs to score at a time
        :param is_match: True to return only matches, False to return only non-matches, None to return all
        pairs
        :param min_score: minimum score for a pair to be included in the results
        :param max_score: The maximum score for a pair to be included in the results
        :param min_loss: minimum loss for a pair to be included in the results
        :param max_loss: The maximum loss for a pair to be included in the results
        &#34;&#34;&#34;
        strings = self.strings
        V = self.V
        w = self.w

        # Create simple slice objects to avoid creating copies with advanced
        # indexing
        i_slice = slice(batch_start, batch_start + batch_size)
        j_slice = slice(batch_start + 1, None)

        X = V[i_slice] @ V[j_slice].T
        Y = (group_ids[i_slice, None] == group_ids[None, j_slice]).float()
        if w is not None:
            W = w[i_slice, None] * w[None, j_slice]
        else:
            W = None

        scores = self.score_model(X)
        loss = self.score_model.loss(X, Y, weights=W)

        # Search upper diagonal entries only
        # (note j_slice starting index is offset by one)
        scores = torch.triu(scores)

        # Filter by match type
        if is_match is not None:
            if is_match:
                scores *= Y
            else:
                scores *= (1 - Y)

        # Filter by min score
        if min_score is not None:
            scores *= (scores &gt;= min_score)

        # Filter by max score
        if max_score is not None:
            scores *= (scores &lt;= max_score)

        # Filter by min loss
        if min_loss is not None:
            scores *= (loss &gt;= min_loss)

        # Filter by max loss
        if max_loss is not None:
            scores *= (loss &lt;= max_loss)

        # Collect scored pairs
        i, j = torch.nonzero(scores, as_tuple=True)

        pairs = np.hstack([
            strings[i.cpu().numpy() + batch_start][:, None],
            strings[j.cpu().numpy() + (batch_start + 1)][:, None]
        ])

        pair_groups = np.hstack([
                                strings[group_ids[i + batch_start].cpu().numpy()][:, None],
                                strings[group_ids[j + (batch_start + 1)].cpu().numpy()][:, None]
                                ])

        pair_scores = scores[i, j].cpu().numpy()
        pair_losses = loss[i, j].cpu().numpy()

        return pairs, pair_groups, pair_scores, pair_losses

    def iter_scored_pairs(
            self,
            matcher=None,
            batch_size=64,
            progress_bar=True,
            **kwargs):
        &#34;&#34;&#34;
        A private method used to process and yield a batch of scored pairs of strings from the input matcher.

        :param matcher: a matcher objec
        :param batch_size: The number of pairs to score at a time, defaults to 64 (optional)
        :param progress_bar: Whether to show a progress bar, defaults to True (optional)
        :param kwargs: Additional keyword arguments to pass to the _batch_scored_pairs method.
        &#34;&#34;&#34;

        if matcher is not None:
            self = self.embed(matcher)
            group_ids = self._matcher_to_group_ids(matcher)
        else:
            group_ids = torch.arange(len(self)).to(self.device)

        for batch_start in tqdm(
                range(
                    0,
                    len(self),
                    batch_size),
                desc=&#39;Scoring pairs&#39;,
                disable=not progress_bar):
            pairs, pair_groups, scores, losses = self._batch_scored_pairs(
                self, group_ids, batch_start, batch_size, **kwargs)
            for (s0, s1), (g0, g1), score, loss in zip(
                    pairs, pair_groups, scores, losses):
                yield {
                    &#39;string0&#39;: s0,
                    &#39;string1&#39;: s1,
                    &#39;group0&#39;: g0,
                    &#39;group1&#39;: g1,
                    &#39;score&#39;: score,
                    &#39;loss&#39;: loss,
                }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nama.embedding_similarity.Embeddings.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nama.embedding_similarity.Embeddings.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nama.embedding_similarity.Embeddings.embed"><code class="name flex">
<span>def <span class="ident">embed</span></span>(<span>self, matcher)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs an updated <code><a title="nama.embedding_similarity.Embeddings" href="#nama.embedding_similarity.Embeddings">Embeddings</a></code> object with counts from the input Matcher.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matcher</code></strong> :&ensp;<code>Matcher</code></dt>
<dd>A <code>Matcher</code> object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="nama.embedding_similarity.Embeddings" href="#nama.embedding_similarity.Embeddings">Embeddings</a></code></dt>
<dd>A new <code><a title="nama.embedding_similarity.Embeddings" href="#nama.embedding_similarity.Embeddings">Embeddings</a></code> object with updated counts and weights.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed(self, matcher):
    &#34;&#34;&#34;
    Constructs an updated `Embeddings` object with counts from the input Matcher.

    Parameters
    ----------
    matcher : Matcher
        A `Matcher` object.

    Returns
    -------
    Embeddings
        A new `Embeddings` object with updated counts and weights.
    &#34;&#34;&#34;
    new = self[matcher]
    new.counts = torch.tensor([matcher.counts[s]
                              for s in new.strings], device=self.device)
    new.w = new.weighting_function(new.counts)

    return new</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.Embeddings.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, *input: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _forward_unimplemented(self, *input: Any) -&gt; None:
    r&#34;&#34;&#34;Defines the computation performed at every call.

    Should be overridden by all subclasses.

    .. note::
        Although the recipe for forward pass needs to be defined within
        this function, one should call the :class:`Module` instance afterwards
        instead of this since the former takes care of running the
        registered hooks while the latter silently ignores them.
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Module [{type(self).__name__}] is missing the required \&#34;forward\&#34; function&#34;)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.Embeddings.iter_scored_pairs"><code class="name flex">
<span>def <span class="ident">iter_scored_pairs</span></span>(<span>self, matcher=None, batch_size=64, progress_bar=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A private method used to process and yield a batch of scored pairs of strings from the input matcher.</p>
<p>:param matcher: a matcher objec
:param batch_size: The number of pairs to score at a time, defaults to 64 (optional)
:param progress_bar: Whether to show a progress bar, defaults to True (optional)
:param kwargs: Additional keyword arguments to pass to the _batch_scored_pairs method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_scored_pairs(
        self,
        matcher=None,
        batch_size=64,
        progress_bar=True,
        **kwargs):
    &#34;&#34;&#34;
    A private method used to process and yield a batch of scored pairs of strings from the input matcher.

    :param matcher: a matcher objec
    :param batch_size: The number of pairs to score at a time, defaults to 64 (optional)
    :param progress_bar: Whether to show a progress bar, defaults to True (optional)
    :param kwargs: Additional keyword arguments to pass to the _batch_scored_pairs method.
    &#34;&#34;&#34;

    if matcher is not None:
        self = self.embed(matcher)
        group_ids = self._matcher_to_group_ids(matcher)
    else:
        group_ids = torch.arange(len(self)).to(self.device)

    for batch_start in tqdm(
            range(
                0,
                len(self),
                batch_size),
            desc=&#39;Scoring pairs&#39;,
            disable=not progress_bar):
        pairs, pair_groups, scores, losses = self._batch_scored_pairs(
            self, group_ids, batch_start, batch_size, **kwargs)
        for (s0, s1), (g0, g1), score, loss in zip(
                pairs, pair_groups, scores, losses):
            yield {
                &#39;string0&#39;: s0,
                &#39;string1&#39;: s1,
                &#39;group0&#39;: g0,
                &#39;group1&#39;: g1,
                &#39;score&#39;: score,
                &#39;loss&#39;: loss,
            }</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.Embeddings.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, threshold=0.5, group_threshold=None, separate_strings=[], base_matcher=None, batch_size=64, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Unite embedding strings according to predicted pairwise similarity.</p>
<ul>
<li>"base_matcher" will be used to inialize the group_ids before uniting new matches</li>
<li>"theshold" sets the minimimum match similarity required to unite two strings.<ul>
<li>Note that strings with similarity&lt;threshold can end up matched if they are
linked by a chain of sufficiently similar strings (matching is transitive).
"group_threshold" can be used to add an additional constraing on the minimum
similarity within each group.</li>
</ul>
</li>
<li>"group_threshold" sets the minimum similarity required within a single group.
If "group_threshold" != None, string pairs with similarity&gt;threshold are identified
and stored in order of similarity. Highest similarity strings are matched first,
and before each time a pair of strings is united, the function checks if this will
result in grouping any two strings with similarity&lt;group_threshold. If so, this pair
is skipped. This version of the algorithm is slower than the one used when
"group_threshold=None.</li>
<li>"separate_strings" takes a list of strings that should never be united with each
other (these strings will still be united with other strings)</li>
</ul>
<p>:param threshold: The minimum similarity required to unite two strings
:param group_threshold: the minimum similarity required within a single group
:param separate_strings: a list of strings that should never be united with each other (these
strings will still be united with other strings)
:param base_matcher: This is a matcher object that you can use to initialize the group_ids before
uniting new matches
:param batch_size: The number of embeddings to process at once, defaults to 64 (optional)
:param progress_bar: Whether to show a progress bar, defaults to True (optional)
:return: A Matcher object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@torch.no_grad()
def predict(self,
            threshold=0.5,
            group_threshold=None,
            separate_strings=[],
            base_matcher=None,
            batch_size=64,
            progress_bar=True):
    &#34;&#34;&#34;
    Unite embedding strings according to predicted pairwise similarity.

    - &#34;base_matcher&#34; will be used to inialize the group_ids before uniting new matches
    - &#34;theshold&#34; sets the minimimum match similarity required to unite two strings.
        - Note that strings with similarity&lt;threshold can end up matched if they are
          linked by a chain of sufficiently similar strings (matching is transitive).
          &#34;group_threshold&#34; can be used to add an additional constraing on the minimum
          similarity within each group.
    - &#34;group_threshold&#34; sets the minimum similarity required within a single group.
      If &#34;group_threshold&#34; != None, string pairs with similarity&gt;threshold are identified
      and stored in order of similarity. Highest similarity strings are matched first,
      and before each time a pair of strings is united, the function checks if this will
      result in grouping any two strings with similarity&lt;group_threshold. If so, this pair
      is skipped. This version of the algorithm is slower than the one used when
      &#34;group_threshold=None.
    - &#34;separate_strings&#34; takes a list of strings that should never be united with each
      other (these strings will still be united with other strings)

    :param threshold: The minimum similarity required to unite two strings
    :param group_threshold: the minimum similarity required within a single group
    :param separate_strings: a list of strings that should never be united with each other (these
    strings will still be united with other strings)
    :param base_matcher: This is a matcher object that you can use to initialize the group_ids before
    uniting new matches
    :param batch_size: The number of embeddings to process at once, defaults to 64 (optional)
    :param progress_bar: Whether to show a progress bar, defaults to True (optional)
    :return: A Matcher object
    &#34;&#34;&#34;

    # Use the faster prediction algorithm if possible
    if not (group_threshold or separate_strings):

        return self._fast_predict(
            threshold=threshold,
            base_matcher=base_matcher,
            batch_size=batch_size,
            progress_bar=progress_bar)

    if base_matcher is not None:
        # self = self.embed(base_matcher)
        group_ids = self._matcher_to_group_ids(base_matcher)
    else:
        group_ids = torch.arange(len(self)).to(self.device)

    V = self.V
    cos_threshold = self.score_model.score_to_cos(threshold)
    if group_threshold is not None:
        separate_cos = self.score_model.score_to_cos(group_threshold)

    # First collect all pairs to match (can be memory intensive!)
    matches = []
    cos_scores = []
    for batch_start in tqdm(range(0, len(self), batch_size),
                            desc=&#39;Scoring pairs&#39;,
                            delay=1, disable=not progress_bar):

        i_slice = slice(batch_start, batch_start + batch_size)
        j_slice = slice(batch_start + 1, None)

        # Find j&#39;s with jaccard &gt; threshold (&#34;matches&#34;)
        batch_cos = V[i_slice] @ V[j_slice].T

        # Search upper diagonal entries only
        # (note j_slice starting index is offset by one)
        batch_cos = torch.triu(batch_cos)

        bi, bj = torch.nonzero(batch_cos &gt;= cos_threshold, as_tuple=True)

        if len(bi):
            # Convert batch index locations to global index locations
            i = bi + batch_start
            j = bj + batch_start + 1

            cos = batch_cos[bi, bj]

            # Can skip strings that are already matched in the base matcher
            unmatched = group_ids[i] != group_ids[j]
            i = i[unmatched]
            j = j[unmatched]
            cos = cos[unmatched]

            if len(i):
                batch_matches = torch.hstack([i[:, None], j[:, None]])

                matches.append(batch_matches.to(&#39;cpu&#39;).numpy())
                cos_scores.append(cos.to(&#39;cpu&#39;).numpy())

    # Then unite the pairs in priority order, checking for violations of the
    # separation arguments
    if matches:
        matches = np.vstack(matches)
        cos_scores = np.hstack(cos_scores).T

        # Sort matches in descending order of score
        m_sort = cos_scores.argsort()[::-1]
        matches = matches[m_sort]

        # Set up tensors
        matches = torch.tensor(matches).to(self.device)
        separate_strings = set(separate_strings)
        separated = torch.tensor(
            [s in separate_strings for s in self.strings]).to(self.device)

        n_matches = matches.shape[0]
        with tqdm(total=n_matches, desc=&#39;Uniting matches&#39;,
                  delay=1, disable=not progress_bar) as p_bar:

            while len(matches):

                # Select the current match pair and remove it from the
                # queue
                match_pair = matches[0]
                matches = matches[1:]

                # Get the groups of the current match pair
                g = group_ids[match_pair]

                # Identify which strings should be united
                to_unite = (group_ids == g[0]) | (group_ids == g[1])

                # Flag whether uniting this pair will unite any separated
                # strings
                any_separated = separated[to_unite].sum() &gt; 1

                # Flag whether the new group will have three or more
                # strings
                singletons = to_unite.sum() &lt; 3

                if any_separated:
                    unite_ok = False
                else:
                    if singletons:
                        unite_ok = True
                    else:
                        if group_threshold is None:
                            unite_ok = True
                        else:
                            V0 = V[group_ids == g[0], :]
                            V1 = V[group_ids == g[1], :]

                            unite_ok = (V0 @ V1.T).min() &gt;= separate_cos

                if unite_ok:

                    # Unite groups
                    group_ids[to_unite] = g[0]

                    # If we are uniting more than two strings, we can eliminate
                    # some redundant matches in the queue
                    if not singletons:
                        # Removed queued matches that are now in the same
                        # group
                        matches = matches[group_ids[matches[:, 0]]
                                          != group_ids[matches[:, 1]]]
                else:
                    # Remove queued matches connecting these groups
                    matches = matches[torch.isin(group_ids[matches[:, 0]], g, invert=True)
                                      | torch.isin(group_ids[matches[:, 1]], g, invert=True)]

                # Update progress bar
                p_bar.update(n_matches - matches.shape[0])
                n_matches = matches.shape[0]

    return self._group_ids_to_matcher(group_ids)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.Embeddings.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the embedding vectors, score model, weighting function, and strings and counts to an archive format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>str</code></dt>
<dd>The file to save to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, f):
    &#34;&#34;&#34;
    Saves the embedding vectors, score model, weighting function, and strings and counts to an archive format.

    Parameters
    ----------
    f : str
        The file to save to.
    &#34;&#34;&#34;
    with ZipFile(f, &#39;w&#39;) as zip:

        # Write score model
        zip.writestr(&#39;score_model.pkl&#39;, pickle.dumps(self.score_model))

        # Write score model
        zip.writestr(
            &#39;weighting_function.pkl&#39;,
            pickle.dumps(
                self.weighting_function))

        # Write string info
        strings_df = pd.DataFrame().assign(
            string=self.strings,
            count=self.counts.to(&#39;cpu&#39;).numpy())
        zip.writestr(&#39;strings.csv&#39;, strings_df.to_csv(index=False))

        # Write embedding vectors
        byte_io = BytesIO()
        np.save(byte_io, self.V.to(&#39;cpu&#39;).numpy(), allow_pickle=False)
        zip.writestr(&#39;V.npy&#39;, byte_io.getvalue())</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.Embeddings.to"><code class="name flex">
<span>def <span class="ident">to</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the model to a specified device.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device</code></strong> :&ensp;<code>str</code></dt>
<dd>The device to run the model on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to(self, device):
    &#34;&#34;&#34;
    Moves the model to a specified device.

    Parameters
    ----------
    device : str
        The device to run the model on.
    &#34;&#34;&#34;
    super().to(device)
    self.V = self.V.to(device)
    self.counts = self.counts.to(device)
    self.w = self.w.to(device)
    self.score_model.to(device)
    self.device = device</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.Embeddings.voronoi"><code class="name flex">
<span>def <span class="ident">voronoi</span></span>(<span>self, seed_strings, threshold=0, base_matcher=None, progress_bar=True, batch_size=64)</span>
</code></dt>
<dd>
<div class="desc"><p>Unite embedding strings with each string's most similar seed string.</p>
<ul>
<li>"base_matcher" will be used to inialize the group_ids before uniting new matches</li>
<li>"theshold" sets the minimimum match similarity required between a string and seed string
for the string to be matched. (i.e., setting theshold=0 will result in every embedding
string to be matched its nearest seed string, while setting threshold=0.9 will leave
strings that have similarity&lt;0.9 with their nearest seed string unaffected)</li>
</ul>
<p>returns: Matcher object</p>
<p>:param seed_strings: a list of strings to use as seed strings
:param threshold: The minimum similarity score required for a match, defaults to 0 (optional)
:param base_matcher: The matcher object to use as a starting point. If None, then the embedding
strings will be used as the starting point
:param progress_bar: Whether to show a progress bar, defaults to True (optional)
:param batch_size: The number of embedding strings to process at a time, defaults to 64
(optional)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@torch.no_grad()
def voronoi(
        self,
        seed_strings,
        threshold=0,
        base_matcher=None,
        progress_bar=True,
        batch_size=64):
    &#34;&#34;&#34;
    Unite embedding strings with each string&#39;s most similar seed string.

    - &#34;base_matcher&#34; will be used to inialize the group_ids before uniting new matches
    - &#34;theshold&#34; sets the minimimum match similarity required between a string and seed string
      for the string to be matched. (i.e., setting theshold=0 will result in every embedding
      string to be matched its nearest seed string, while setting threshold=0.9 will leave
      strings that have similarity&lt;0.9 with their nearest seed string unaffected)

    returns: Matcher object

    :param seed_strings: a list of strings to use as seed strings
    :param threshold: The minimum similarity score required for a match, defaults to 0 (optional)
    :param base_matcher: The matcher object to use as a starting point. If None, then the embedding
    strings will be used as the starting point
    :param progress_bar: Whether to show a progress bar, defaults to True (optional)
    :param batch_size: The number of embedding strings to process at a time, defaults to 64
    (optional)
    &#34;&#34;&#34;

    if base_matcher is not None:
        # self = self.embed(base_matcher)
        group_ids = self._matcher_to_group_ids(base_matcher)
    else:
        group_ids = torch.arange(len(self)).to(self.device)

    V = self.V
    cos_threshold = self.score_model.score_to_cos(threshold)

    seed_ids = torch.tensor([self.string_map[s]
                            for s in seed_strings]).to(self.device)
    V_seed = V[seed_ids]
    g_seed = group_ids[seed_ids]
    is_seed = torch.zeros(V.shape[0], dtype=torch.bool).to(self.device)
    is_seed[g_seed] = True

    for batch_start in tqdm(
            range(
                0,
                len(self),
                batch_size),
            delay=1,
            desc=&#39;Predicting matches&#39;,
            disable=not progress_bar):

        batch_slice = slice(batch_start, batch_start + batch_size)

        batch_cos = V[batch_slice] @ V_seed.T

        max_cos, max_seed = torch.max(batch_cos, dim=1)

        # Get batch index locations where score &gt; threshold
        batch_i = torch.nonzero(max_cos &gt; cos_threshold)

        if len(batch_i):
            # Drop seed strings from matches (otherwise numerical precision
            # issues can allow seed strings to match to other strings)
            batch_i = batch_i[~is_seed[batch_slice][batch_i]]

            if len(batch_i):
                # Get indices of matched strings
                i = batch_i + batch_start

                # Assign matched strings to the seed string&#39;s group
                group_ids[i] = g_seed[max_seed[batch_i]]

    return self._group_ids_to_matcher(group_ids)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nama.embedding_similarity.ExpCosSimilarity"><code class="flex name class">
<span>class <span class="ident">ExpCosSimilarity</span></span>
<span>(</span><span>alpha=50, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A trainable similarity scoring model that estimates the probability
of a match as the negative exponent of 1+cosine distance between</p>
<p>embeddings: p(match|v_i,v_j) = exp(-alpha*(1-v_i@v_j))</p>
<p>Initializes an a trainable alpha.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The alpha parameter in the paper, defaults to 50.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpCosSimilarity(nn.Module):
    &#34;&#34;&#34;
    A trainable similarity scoring model that estimates the probability
    of a match as the negative exponent of 1+cosine distance between

    embeddings: p(match|v_i,v_j) = exp(-alpha*(1-v_i@v_j))
    &#34;&#34;&#34;

    def __init__(self, alpha=50, **kwargs):
        &#34;&#34;&#34;
        Initializes an a trainable alpha.

        Parameters
        ----------
        alpha: float, optional
            The alpha parameter in the paper, defaults to 50.
        &#34;&#34;&#34;

        super().__init__()

        self.alpha = nn.Parameter(torch.tensor(float(alpha)))

    def __repr__(self):
        &#34;&#34;&#34;
        Returns a string representation of the object.
        &#34;&#34;&#34;
        return f&#39;&lt;nama.ExpCosSimilarity with {self.alpha=}&gt;&#39;

    def forward(self, X):
        &#34;&#34;&#34;
        Scores a set of embedding similarities, returns a score between 0 and 1.

        Parameters
        ----------
        X: torch tensor
            the distance between the embeddings vectors

        Returns
        -------
        The score of the embeddings: torch tensor
        &#34;&#34;&#34;
        # Z is a scaled distance measure: Z=0 means that the score should be 1
        Z = self.alpha * (1 - X)
        return torch.clamp(torch.exp(-Z), min=0, max=1.0)

    def loss(self, X, Y, weights=None, decay=1e-6, epsilon=1e-6):
        &#34;&#34;&#34;
        Calculates the cross entropy loss with a simplified and numerically appropriate formula.
        $ $

        Parameters
        ----------
        X: torch tensor
            The set of embedding similarities
        Y: torch tensor
            The true labels
        weights: torch tensor, optional
            a tensor used to weights for the loss
        decay: float, optional
            This is the regularization parameter. It&#39;s a hyperparameter that can be tuned, defaults to 1e-6.
        epsilon: float, optional
            This is a small number that is added to the denominator to prevent division by zero, defaults to 1e-6.

        Returns
        -------
        The cross entropy loss of the embeddings: torch tensor
        &#34;&#34;&#34;

        Z = self.alpha * (1 - X)

        # Put epsilon floor to prevent overflow/undefined results
        with torch.no_grad():
            Z_eps_adjustment = torch.clamp(epsilon - Z, min=0)

        Z += Z_eps_adjustment

        loss = Y * Z - torch.xlogy(1 - Y, -torch.expm1(-Z))

        if weights is not None:
            loss *= weights * loss

        if decay:
            loss += decay * self.alpha**2

        return loss

    def score_to_cos(self, score):
        &#34;&#34;&#34;
        It takes a score and returns a cosine similarity.

        Parameters
        ----------
        score: float
            the score of the item

        Returns
        -------
        The cosine similarity between the two vectors: float
        &#34;&#34;&#34;
        if score &gt; 0:
            return 1 + np.log(score) / self.alpha.item()
        else:
            return -99

    def config_optimizer(self, lr=10):
        &#34;&#34;&#34;
        Sets the configuration of the ExpCosSimilarity optimizer

        Parameters
        ----------
        lr: float
            Learning rate for the loss function

        Returns
        -------
        optimizer: torch.optim.AdamW
            The configured optimizer
        &#34;&#34;&#34;
        optimizer = torch.optim.AdamW(self.parameters(), lr=lr, weight_decay=0)

        return optimizer</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nama.embedding_similarity.ExpCosSimilarity.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nama.embedding_similarity.ExpCosSimilarity.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nama.embedding_similarity.ExpCosSimilarity.config_optimizer"><code class="name flex">
<span>def <span class="ident">config_optimizer</span></span>(<span>self, lr=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the configuration of the ExpCosSimilarity optimizer</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lr</code></strong> :&ensp;<code>float</code></dt>
<dd>Learning rate for the loss function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>optimizer</code></strong> :&ensp;<code>torch.optim.AdamW</code></dt>
<dd>The configured optimizer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_optimizer(self, lr=10):
    &#34;&#34;&#34;
    Sets the configuration of the ExpCosSimilarity optimizer

    Parameters
    ----------
    lr: float
        Learning rate for the loss function

    Returns
    -------
    optimizer: torch.optim.AdamW
        The configured optimizer
    &#34;&#34;&#34;
    optimizer = torch.optim.AdamW(self.parameters(), lr=lr, weight_decay=0)

    return optimizer</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.ExpCosSimilarity.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, X) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Scores a set of embedding similarities, returns a score between 0 and 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>torch tensor</code></dt>
<dd>the distance between the embeddings vectors</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The score</code> of <code>the embeddings: torch tensor</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, X):
    &#34;&#34;&#34;
    Scores a set of embedding similarities, returns a score between 0 and 1.

    Parameters
    ----------
    X: torch tensor
        the distance between the embeddings vectors

    Returns
    -------
    The score of the embeddings: torch tensor
    &#34;&#34;&#34;
    # Z is a scaled distance measure: Z=0 means that the score should be 1
    Z = self.alpha * (1 - X)
    return torch.clamp(torch.exp(-Z), min=0, max=1.0)</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.ExpCosSimilarity.loss"><code class="name flex">
<span>def <span class="ident">loss</span></span>(<span>self, X, Y, weights=None, decay=1e-06, epsilon=1e-06)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the cross entropy loss with a simplified and numerically appropriate formula.
$ $</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>torch tensor</code></dt>
<dd>The set of embedding similarities</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>torch tensor</code></dt>
<dd>The true labels</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>torch tensor</code>, optional</dt>
<dd>a tensor used to weights for the loss</dd>
<dt><strong><code>decay</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>This is the regularization parameter. It's a hyperparameter that can be tuned, defaults to 1e-6.</dd>
<dt><strong><code>epsilon</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>This is a small number that is added to the denominator to prevent division by zero, defaults to 1e-6.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The cross entropy loss</code> of <code>the embeddings: torch tensor</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loss(self, X, Y, weights=None, decay=1e-6, epsilon=1e-6):
    &#34;&#34;&#34;
    Calculates the cross entropy loss with a simplified and numerically appropriate formula.
    $ $

    Parameters
    ----------
    X: torch tensor
        The set of embedding similarities
    Y: torch tensor
        The true labels
    weights: torch tensor, optional
        a tensor used to weights for the loss
    decay: float, optional
        This is the regularization parameter. It&#39;s a hyperparameter that can be tuned, defaults to 1e-6.
    epsilon: float, optional
        This is a small number that is added to the denominator to prevent division by zero, defaults to 1e-6.

    Returns
    -------
    The cross entropy loss of the embeddings: torch tensor
    &#34;&#34;&#34;

    Z = self.alpha * (1 - X)

    # Put epsilon floor to prevent overflow/undefined results
    with torch.no_grad():
        Z_eps_adjustment = torch.clamp(epsilon - Z, min=0)

    Z += Z_eps_adjustment

    loss = Y * Z - torch.xlogy(1 - Y, -torch.expm1(-Z))

    if weights is not None:
        loss *= weights * loss

    if decay:
        loss += decay * self.alpha**2

    return loss</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.ExpCosSimilarity.score_to_cos"><code class="name flex">
<span>def <span class="ident">score_to_cos</span></span>(<span>self, score)</span>
</code></dt>
<dd>
<div class="desc"><p>It takes a score and returns a cosine similarity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>the score of the item</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The cosine similarity between the two vectors: float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_to_cos(self, score):
    &#34;&#34;&#34;
    It takes a score and returns a cosine similarity.

    Parameters
    ----------
    score: float
        the score of the item

    Returns
    -------
    The cosine similarity between the two vectors: float
    &#34;&#34;&#34;
    if score &gt; 0:
        return 1 + np.log(score) / self.alpha.item()
    else:
        return -99</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nama.embedding_similarity.ExponentWeights"><code class="flex name class">
<span>class <span class="ident">ExponentWeights</span></span>
<span>(</span><span>weighting_exponent=0.5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The ExponentWeights class is used to calculate the weighted counts with a specified exponent.</p>
<p>Initialize the class with the specified weighting exponent.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>weighting_exponent</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The exponent to use for the weighting of the counts (default is 0.5).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExponentWeights():
    &#34;&#34;&#34;The ExponentWeights class is used to calculate the weighted counts with a specified exponent.&#34;&#34;&#34;

    def __init__(self, weighting_exponent=0.5, **kwargs):
        &#34;&#34;&#34;
        Initialize the class with the specified weighting exponent.

        Parameters
        ----------
        weighting_exponent : float, optional
            The exponent to use for the weighting of the counts (default is 0.5).
        &#34;&#34;&#34;
        self.exponent = weighting_exponent

    def __call__(self, counts):
        &#34;&#34;&#34;
        Calculate the weighted counts using the specified exponent.

        Parameters
        ----------
        counts : np.ndarray
            The counts to be weighted.

        Returns
        -------
        np.ndarray
            The weighted counts.
        &#34;&#34;&#34;
        return counts**self.exponent</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.TransformerProjector"><code class="flex name class">
<span>class <span class="ident">TransformerProjector</span></span>
<span>(</span><span>model_class=transformers.models.roberta.modeling_roberta.RobertaModel, model_name='roberta-base', pooling='pooler', normalize=True, d=128, prompt='', device='cpu', add_upper=True, upper_case=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A basic wrapper around a Hugging Face transformer model.
Takes a string as input and produces an embedding vector of size d.</p>
<p>Initializes the TransformerProjector class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_class</code></strong> :&ensp;<code>The transformer model class</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>model_name</code></strong> :&ensp;<code>str</code>, optional <code>(default='roberta-base')</code></dt>
<dd>The name of the pretrained model to use.</dd>
<dt><strong><code>pooling</code></strong> :&ensp;<code>str</code>, optional <code>(default='pooler')</code></dt>
<dd>The pooling method to use. Options are:</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>Whether to normalize the embeddings to unit length.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>int</code>, optional <code>(default=128)</code></dt>
<dd>The dimension of the embedding space. If you want to use the original embedding space, set this to None.</dd>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code></dt>
<dd>The prompt to use for the essay.</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>str</code>, optional <code>(default='cpu')</code></dt>
<dd>The device to run the model on.</dd>
<dt><strong><code>add_upper</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>If True, adds the upper-cased version of the prompt to the prompt.</dd>
<dt><strong><code>upper_case</code></strong> :&ensp;<code>bool</code>, optional <code>(default=False)</code></dt>
<dd>If True, the input will be converted to upper case.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformerProjector(nn.Module):
    &#34;&#34;&#34;
    A basic wrapper around a Hugging Face transformer model.
    Takes a string as input and produces an embedding vector of size d.
    &#34;&#34;&#34;

    def __init__(self,
                 model_class=RobertaModel,
                 model_name=&#39;roberta-base&#39;,
                 pooling=&#39;pooler&#39;,
                 normalize=True,
                 d=128,
                 prompt=&#39;&#39;,
                 device=&#39;cpu&#39;,
                 add_upper=True,
                 upper_case=False,
                 **kwargs):
        &#34;&#34;&#34;
        Initializes the TransformerProjector class.

        Parameters
        ----------
        model_class: The transformer model class
        model_name: str, optional (default=&#39;roberta-base&#39;)
            The name of the pretrained model to use.
        pooling: str, optional (default=&#39;pooler&#39;)
            The pooling method to use. Options are:
        normalize: bool, optional (default=True)
            Whether to normalize the embeddings to unit length.
        d: int, optional (default=128)
            The dimension of the embedding space. If you want to use the original embedding space, set this to None.
        prompt: str
            The prompt to use for the essay.
        device: str, optional (default=&#39;cpu&#39;)
            The device to run the model on.
        add_upper: bool, optional (default=True)
            If True, adds the upper-cased version of the prompt to the prompt.
        upper_case: bool, optional (default=False)
            If True, the input will be converted to upper case.
        &#34;&#34;&#34;
        super().__init__()

        self.model_class = model_class
        self.model_name = model_name
        self.pooling = pooling
        self.normalize = normalize
        self.d = d
        self.prompt = prompt
        self.add_upper = add_upper
        self.upper_case = upper_case

        self.tokenizer = AutoTokenizer.from_pretrained(model_name)

        try:
            self.transformer = model_class.from_pretrained(model_name)
        except OSError:
            self.transformer = model_class.from_pretrained(
                model_name, from_tf=True)

        self.dropout = torch.nn.Dropout(0.5)

        if d:
            # Project embedding to a lower dimension
            # Initialization based on random projection LSH (preserves
            # approximate cosine distances)
            self.projection = torch.nn.Linear(
                self.transformer.config.hidden_size, d)
            torch.nn.init.normal_(self.projection.weight)
            torch.nn.init.constant_(self.projection.bias, 0)

        self.to(device)

    def to(self, device):
        &#34;&#34;&#34;
        Moves the model to the specified device

        Parameters
        ----------
        device: str
            The device to which the model is to be moved
        &#34;&#34;&#34;
        super().to(device)
        self.device = device

    def encode(self, strings):
        &#34;&#34;&#34;
        Encodes the strings using the tokenizer

        Parameters
        ----------
        strings: list of str
            A list of strings to encode

        Returns
        -------
        input_ids: torch.tensor
            Input ids tensor
        attention_mask: torch.tensor
            Attention mask tensor
        &#34;&#34;&#34;
        if self.prompt is not None:
            strings = [self.prompt + s for s in strings]
        if self.add_upper:
            strings = [s + &#39; &lt;/s&gt; &#39; + s.upper() for s in strings]
        if self.upper_case:
            strings = [s + &#39; &lt;/s&gt; &#39; + s.upper() for s in strings]

        try:
            encoded = self.tokenizer(strings, padding=True, truncation=True)
        except Exception as e:
            print(strings)
            raise Exception(e)
        input_ids = torch.tensor(encoded[&#39;input_ids&#39;]).long()
        attention_mask = torch.tensor(encoded[&#39;attention_mask&#39;])

        return input_ids, attention_mask

    def forward(self, strings):
        &#34;&#34;&#34;
        Encodes the string into batches, and then passes them through the transformer model

        Parameters
        ----------
        strings: list of str
            A list of strings to embed

        Returns
        -------
        v: torch.tensor
            The last hidden state of the transformer
        &#34;&#34;&#34;
        with torch.no_grad():
            input_ids, attention_mask = self.encode(strings)

            input_ids = input_ids.to(device=self.device)
            attention_mask = attention_mask.to(device=self.device)

        # with amp.autocast(self.amp):
        batch_out = self.transformer(input_ids=input_ids,
                                     attention_mask=attention_mask,
                                     return_dict=True)

        if self.pooling == &#39;pooler&#39;:
            v = batch_out[&#39;pooler_output&#39;]
        elif self.pooling == &#39;mean&#39;:
            h = batch_out[&#39;last_hidden_state&#39;]

            # Compute mean of unmasked token vectors
            h = h * attention_mask[:, :, None]
            v = h.sum(dim=1) / attention_mask.sum(dim=1)[:, None]

        if self.d:
            v = self.projection(v)

        if self.normalize:
            v = v / torch.sqrt((v**2).sum(dim=1)[:, None])

        return v

    def config_optimizer(self, transformer_lr=1e-5, projection_lr=1e-4):
        &#34;&#34;&#34;
        Sets the configuration of the TransformerProjector optimizer

        Parameters
        ----------
        transformer_lr: float
            Learning rate for the transformer
        projection_lr: float
            Learning rate for the projection layer

        Returns
        -------
        optimizer: torch.optim.AdamW
            The configured optimizer
        &#34;&#34;&#34;

        parameters = list(self.named_parameters())
        grouped_parameters = [{&#39;params&#39;: [param for name,
                                          param in parameters if name.startswith(&#39;transformer&#39;) and name.endswith(&#39;bias&#39;)],
                               &#39;weight_decay_rate&#39;: 0.0,
                               &#39;lr&#39;: transformer_lr,
                               },
                              {&#39;params&#39;: [param for name,
                                          param in parameters if name.startswith(&#39;transformer&#39;) and not name.endswith(&#39;bias&#39;)],
                               &#39;weight_decay_rate&#39;: 0.0,
                               &#39;lr&#39;: transformer_lr,
                               },
                              {&#39;params&#39;: [param for name,
                                          param in parameters if name.startswith(&#39;projection&#39;)],
                               &#39;weight_decay_rate&#39;: 0.0,
                               &#39;lr&#39;: projection_lr,
                               },
                              ]

        # Drop groups with lr of 0
        grouped_parameters = [p for p in grouped_parameters if p[&#39;lr&#39;]]

        optimizer = torch.optim.AdamW(grouped_parameters)

        return optimizer</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nama.embedding_similarity.TransformerProjector.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nama.embedding_similarity.TransformerProjector.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nama.embedding_similarity.TransformerProjector.config_optimizer"><code class="name flex">
<span>def <span class="ident">config_optimizer</span></span>(<span>self, transformer_lr=1e-05, projection_lr=0.0001)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the configuration of the TransformerProjector optimizer</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformer_lr</code></strong> :&ensp;<code>float</code></dt>
<dd>Learning rate for the transformer</dd>
<dt><strong><code>projection_lr</code></strong> :&ensp;<code>float</code></dt>
<dd>Learning rate for the projection layer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>optimizer</code></strong> :&ensp;<code>torch.optim.AdamW</code></dt>
<dd>The configured optimizer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_optimizer(self, transformer_lr=1e-5, projection_lr=1e-4):
    &#34;&#34;&#34;
    Sets the configuration of the TransformerProjector optimizer

    Parameters
    ----------
    transformer_lr: float
        Learning rate for the transformer
    projection_lr: float
        Learning rate for the projection layer

    Returns
    -------
    optimizer: torch.optim.AdamW
        The configured optimizer
    &#34;&#34;&#34;

    parameters = list(self.named_parameters())
    grouped_parameters = [{&#39;params&#39;: [param for name,
                                      param in parameters if name.startswith(&#39;transformer&#39;) and name.endswith(&#39;bias&#39;)],
                           &#39;weight_decay_rate&#39;: 0.0,
                           &#39;lr&#39;: transformer_lr,
                           },
                          {&#39;params&#39;: [param for name,
                                      param in parameters if name.startswith(&#39;transformer&#39;) and not name.endswith(&#39;bias&#39;)],
                           &#39;weight_decay_rate&#39;: 0.0,
                           &#39;lr&#39;: transformer_lr,
                           },
                          {&#39;params&#39;: [param for name,
                                      param in parameters if name.startswith(&#39;projection&#39;)],
                           &#39;weight_decay_rate&#39;: 0.0,
                           &#39;lr&#39;: projection_lr,
                           },
                          ]

    # Drop groups with lr of 0
    grouped_parameters = [p for p in grouped_parameters if p[&#39;lr&#39;]]

    optimizer = torch.optim.AdamW(grouped_parameters)

    return optimizer</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.TransformerProjector.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, strings)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the strings using the tokenizer</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>input_ids</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input ids tensor</dd>
<dt><strong><code>attention_mask</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Attention mask tensor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, strings):
    &#34;&#34;&#34;
    Encodes the strings using the tokenizer

    Parameters
    ----------
    strings: list of str
        A list of strings to encode

    Returns
    -------
    input_ids: torch.tensor
        Input ids tensor
    attention_mask: torch.tensor
        Attention mask tensor
    &#34;&#34;&#34;
    if self.prompt is not None:
        strings = [self.prompt + s for s in strings]
    if self.add_upper:
        strings = [s + &#39; &lt;/s&gt; &#39; + s.upper() for s in strings]
    if self.upper_case:
        strings = [s + &#39; &lt;/s&gt; &#39; + s.upper() for s in strings]

    try:
        encoded = self.tokenizer(strings, padding=True, truncation=True)
    except Exception as e:
        print(strings)
        raise Exception(e)
    input_ids = torch.tensor(encoded[&#39;input_ids&#39;]).long()
    attention_mask = torch.tensor(encoded[&#39;attention_mask&#39;])

    return input_ids, attention_mask</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.TransformerProjector.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, strings) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the string into batches, and then passes them through the transformer model</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings to embed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>The last hidden state of the transformer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, strings):
    &#34;&#34;&#34;
    Encodes the string into batches, and then passes them through the transformer model

    Parameters
    ----------
    strings: list of str
        A list of strings to embed

    Returns
    -------
    v: torch.tensor
        The last hidden state of the transformer
    &#34;&#34;&#34;
    with torch.no_grad():
        input_ids, attention_mask = self.encode(strings)

        input_ids = input_ids.to(device=self.device)
        attention_mask = attention_mask.to(device=self.device)

    # with amp.autocast(self.amp):
    batch_out = self.transformer(input_ids=input_ids,
                                 attention_mask=attention_mask,
                                 return_dict=True)

    if self.pooling == &#39;pooler&#39;:
        v = batch_out[&#39;pooler_output&#39;]
    elif self.pooling == &#39;mean&#39;:
        h = batch_out[&#39;last_hidden_state&#39;]

        # Compute mean of unmasked token vectors
        h = h * attention_mask[:, :, None]
        v = h.sum(dim=1) / attention_mask.sum(dim=1)[:, None]

    if self.d:
        v = self.projection(v)

    if self.normalize:
        v = v / torch.sqrt((v**2).sum(dim=1)[:, None])

    return v</code></pre>
</details>
</dd>
<dt id="nama.embedding_similarity.TransformerProjector.to"><code class="name flex">
<span>def <span class="ident">to</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the model to the specified device</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device</code></strong> :&ensp;<code>str</code></dt>
<dd>The device to which the model is to be moved</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to(self, device):
    &#34;&#34;&#34;
    Moves the model to the specified device

    Parameters
    ----------
    device: str
        The device to which the model is to be moved
    &#34;&#34;&#34;
    super().to(device)
    self.device = device</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nama" href="index.html">nama</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nama.embedding_similarity.load_similarity_model" href="#nama.embedding_similarity.load_similarity_model">load_similarity_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel" href="#nama.embedding_similarity.EmbeddingSimilarityModel">EmbeddingSimilarityModel</a></code></h4>
<ul class="two-column">
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.dump_patches" href="#nama.embedding_similarity.EmbeddingSimilarityModel.dump_patches">dump_patches</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.embed" href="#nama.embedding_similarity.EmbeddingSimilarityModel.embed">embed</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.forward" href="#nama.embedding_similarity.EmbeddingSimilarityModel.forward">forward</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.load_embeddings" href="#nama.embedding_similarity.EmbeddingSimilarityModel.load_embeddings">load_embeddings</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.predict" href="#nama.embedding_similarity.EmbeddingSimilarityModel.predict">predict</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.save" href="#nama.embedding_similarity.EmbeddingSimilarityModel.save">save</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.test" href="#nama.embedding_similarity.EmbeddingSimilarityModel.test">test</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.to" href="#nama.embedding_similarity.EmbeddingSimilarityModel.to">to</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.train" href="#nama.embedding_similarity.EmbeddingSimilarityModel.train">train</a></code></li>
<li><code><a title="nama.embedding_similarity.EmbeddingSimilarityModel.training" href="#nama.embedding_similarity.EmbeddingSimilarityModel.training">training</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nama.embedding_similarity.Embeddings" href="#nama.embedding_similarity.Embeddings">Embeddings</a></code></h4>
<ul class="two-column">
<li><code><a title="nama.embedding_similarity.Embeddings.dump_patches" href="#nama.embedding_similarity.Embeddings.dump_patches">dump_patches</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.embed" href="#nama.embedding_similarity.Embeddings.embed">embed</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.forward" href="#nama.embedding_similarity.Embeddings.forward">forward</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.iter_scored_pairs" href="#nama.embedding_similarity.Embeddings.iter_scored_pairs">iter_scored_pairs</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.predict" href="#nama.embedding_similarity.Embeddings.predict">predict</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.save" href="#nama.embedding_similarity.Embeddings.save">save</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.to" href="#nama.embedding_similarity.Embeddings.to">to</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.training" href="#nama.embedding_similarity.Embeddings.training">training</a></code></li>
<li><code><a title="nama.embedding_similarity.Embeddings.voronoi" href="#nama.embedding_similarity.Embeddings.voronoi">voronoi</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nama.embedding_similarity.ExpCosSimilarity" href="#nama.embedding_similarity.ExpCosSimilarity">ExpCosSimilarity</a></code></h4>
<ul class="two-column">
<li><code><a title="nama.embedding_similarity.ExpCosSimilarity.config_optimizer" href="#nama.embedding_similarity.ExpCosSimilarity.config_optimizer">config_optimizer</a></code></li>
<li><code><a title="nama.embedding_similarity.ExpCosSimilarity.dump_patches" href="#nama.embedding_similarity.ExpCosSimilarity.dump_patches">dump_patches</a></code></li>
<li><code><a title="nama.embedding_similarity.ExpCosSimilarity.forward" href="#nama.embedding_similarity.ExpCosSimilarity.forward">forward</a></code></li>
<li><code><a title="nama.embedding_similarity.ExpCosSimilarity.loss" href="#nama.embedding_similarity.ExpCosSimilarity.loss">loss</a></code></li>
<li><code><a title="nama.embedding_similarity.ExpCosSimilarity.score_to_cos" href="#nama.embedding_similarity.ExpCosSimilarity.score_to_cos">score_to_cos</a></code></li>
<li><code><a title="nama.embedding_similarity.ExpCosSimilarity.training" href="#nama.embedding_similarity.ExpCosSimilarity.training">training</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nama.embedding_similarity.ExponentWeights" href="#nama.embedding_similarity.ExponentWeights">ExponentWeights</a></code></h4>
</li>
<li>
<h4><code><a title="nama.embedding_similarity.TransformerProjector" href="#nama.embedding_similarity.TransformerProjector">TransformerProjector</a></code></h4>
<ul class="two-column">
<li><code><a title="nama.embedding_similarity.TransformerProjector.config_optimizer" href="#nama.embedding_similarity.TransformerProjector.config_optimizer">config_optimizer</a></code></li>
<li><code><a title="nama.embedding_similarity.TransformerProjector.dump_patches" href="#nama.embedding_similarity.TransformerProjector.dump_patches">dump_patches</a></code></li>
<li><code><a title="nama.embedding_similarity.TransformerProjector.encode" href="#nama.embedding_similarity.TransformerProjector.encode">encode</a></code></li>
<li><code><a title="nama.embedding_similarity.TransformerProjector.forward" href="#nama.embedding_similarity.TransformerProjector.forward">forward</a></code></li>
<li><code><a title="nama.embedding_similarity.TransformerProjector.to" href="#nama.embedding_similarity.TransformerProjector.to">to</a></code></li>
<li><code><a title="nama.embedding_similarity.TransformerProjector.training" href="#nama.embedding_similarity.TransformerProjector.training">training</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>